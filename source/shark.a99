*********************************************************************
*
* Flying Shark
* For the TI-99/4A home computer
*
* August 2017
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*
*********************************************************************

       def  main

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base
namet1 equ  >2800                      ; Name table base 1 >A
namet2 equ  >2c00                      ; Name table base 2 >B
namet3 equ  >3000                      ; Name table base 3 >C
namet4 equ  >3400                      ; Name table base 4 >D
sprat1 equ  >3700                      ; Sprite attribute table base 1
sprat2 equ  >3780                      ; Sprite attribute table base 2

**
* Constants
*
start_level:
       equ  0
cart_base:
       equ  >603C
scr_width:                             ; Width of screen in characters
       equ  32
scr_height:                            ; Height of screen in characters
       equ  24
win_width:                             ; Width of scrolling window in characters
       equ  18
win_height:                            ; Height of scrolling window in characters
       equ  24
map_width:                             ; Map width
       equ  18
map_left:                              ; Map start column
       equ  14
panel_left:                            ; Panel start column
       equ  0
x_min:                                 ; Minimum x position
       equ  map_left*8
x_max:                                 ; Maximum x position
       equ  (map_left+map_width)*8
n_sprites:                             ; Number of sprites
       equ  16
n_hw_sprites:                          ; Number of hardware sprites
       equ  32

**
* Structures
*
* Sprite definition types
sprite_type_player:
       equ  0
sprite_type_bullet:
       equ  1
sprite_type_turret:
       equ  2
sprite_type_enemy_bullet:
       equ  3
sprite_type_enemy_plane:
       equ  4
sprite_type_tank:
       equ  5
sprite_type_mask:
       equ  6

* Sprite definition structure
sprite_def_type:                       ; Sprite type
       equ  0
sprite_def_width:                      ; Width
       equ  2
sprite_def_height:                     ; Height
       equ  4
sprite_def_left:                       ; Left
       equ  6
sprite_def_top:                        ; Top
       equ  8
sprite_def_size:                       ; Number of hw sprites
       equ  10
sprite_def_pattern:                    ; Base pattern
       equ  12
sprite_def_color:                      ; Base color
       equ  14
sprite_def_struct_size:                ; Structure size
       equ  16

* Sprite states
sprite_state_normal:
       equ  0
sprite_state_damaged:
       equ  1
sprite_state_destroyed:
       equ  2

* Sprite structure
sprite_def:                            ; Pointer to sprite definition structure
       equ  0
sprite_x:                              ; x position
       equ  2
sprite_y:                              ; y position
       equ  4
sprite_vx:                             ; x velocity
       equ  6
sprite_vy:                             ; y velocity
       equ  8
sprite_hw_1:                           ; Hardware sprite 1
       equ  10
sprite_hw_2:                           ; Hardware sprite 2
       equ  12
sprite_hw_3:                           ; Hardware sprite 3
       equ  14
sprite_hw_4:                           ; Hardware sprite 4
       equ  16
sprite_scroll_y:                       ; Reference scroll position
       equ  18
sprite_link:                           ; Linked sprite
       equ  20
sprite_count:                          ; Counter
       equ  22
sprite_path:                           ; Path
       equ  24
sprite_state:                          ; State
       equ  26
sprite_struct_size:                    ; Structure size
       equ  28

* Sprite position structure
sprite_pos_scroll_y:
       equ  0
sprite_pos_x:
       equ  2
sprite_pos_y:
       equ  4
sprite_pos_def:
       equ  6
sprite_pos_path:
       equ  8
sprite_pos_struct_size:
       equ  10

* Hardware sprite structure
hw_sprite:                             ; Pointer to sprite structure
       equ  0
hw_sprite_dx:                          ; Offset from sprite_x
       equ  2
hw_sprite_dy:                          ; Offset from sprite_y
       equ  4
hw_sprite_pattern:                     ; Pattern
       equ  6
hw_sprite_color:                       ; Color
       equ  8
hw_sprite_priority:                    ; Priority: 0, 1, 2 (0 highest)
       equ  10
hw_sprite_struct_size:                 ; Structure size
       equ  12

* Path structure
path_count:
       equ  0
path_vx:
       equ  2
path_vy:
       equ  4
path_pattern:
       equ  6
path_action:
       equ  8
path_struct_size:
       equ  10

**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; R0 low byte required for VDP routines
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
r4lb   equ  wrksp+9
r5lb   equ  wrksp+11
r6lb   equ  wrksp+13
r7lb   equ  wrksp+15
r8lb   equ  wrksp+17
r9lb   equ  wrksp+19
wrksp2 equ  >8320
stack  equ  >8340
padvar equ  stack+>10
*
* PAD variables
*
one:
       equ  padvar
eight:
       equ  one+2
level:
       equ  eight+2
scrly:
       equ  level+2
scrly_current:
       equ  scrly+2
map_height:
       equ  scrly_current+2
diff_ptr:
       equ  map_height+2
max_chars:
       equ  diff_ptr+2
cart_pattern_bank:
       equ  max_chars+2
cart_color_bank:
       equ  cart_pattern_bank+2
cart_map_bank:
       equ  cart_color_bank+2
cart_map_high_bank:
       equ  cart_map_bank+2
frame_count:
       equ  cart_map_high_bank+2
vdp_status:
       equ  frame_count+2
player_fire:
       equ  vdp_status+2
sprite_pos_ptr:
       equ  player_fire+2
sprite_table_flag:
       equ  sprite_pos_ptr+2
angle:
       equ  sprite_table_flag+2
max_hw_sprite:
       equ  angle+2
rand_no:
       equ  max_hw_sprite+2
upload_character_table_pad:
       equ  rand_no+2
pad_max:
       equ  upload_character_table_pad+52

********************************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10, stack                 ; Setup stack pointer
       mov  @rndsd,@rand_no
       bl   @gmode                     ; Setup graphics mode
       bl   @init                      ; One time initializations
next_level:
       bl   @init_level                ; Initialize level
       bl   @draw_initial_screen
main_loop:
       clr  @frame_count
       bl   @game_frame_actions
       bl   @vsync
       bl   @set_name_table
       bl   @set_sprite_table
       bl   @update_char_list
       bl   @update_characters
       bl   @update_name_table
*      Delay
       li   r2,3
       s    @frame_count,r2
       jlt  !
       jeq  !
delay: bl   @vsync
       bl   @interrupt_routine
       dec  r2
       jne  delay
*      Change scroll position
!      mov  @scrly,@scrly_current
       dec  @scrly
       jne  main_loop
*      Next level
       inc  @level
       li   r0,>fff8
       szc  r0,@level
       jmp  next_level
*// main

********************************************************************************
*
* "Interrupt routine"
*
* Changes r12 in calling workspace
*
interrupt_check:
       clr  r12
       tb   2                          ; Did an interrupt occur?
       jeq  interrupt_routine_end      ; No - jump
       movb @vdpsta,@vdp_status
*      Interrupt occurred
interrupt_routine:
       mov  r10,@wrksp2+20             ; Use same SP in new workspace
       lwpi wrksp2                     ; Switch to new workspace
       bl   @game_frame_actions
;      bl   @vsync
       bl   @set_sprite_table
       lwpi wrksp                      ; Switch to old workspace
interrupt_routine_end:
       b    *r11
*// interrupt_routine

*********************************************************************
*
* Game frame actions
*
game_frame_actions:
       mov  r11,*r10+
       mov  @frame_count,r0
       andi r0,1
       jne  game_frame_actions_1
       bl   @user_input
       bl   @fire
       bl   @add_sprites
       bl   @update_sprites            ; Moved up
game_frame_actions_1:
       bl   @upload_sprites
       inc  @frame_count
*      Return
       dect r10
       mov  *r10,r11
       b    *r11
*// game_frame_actions

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       movb @vdpsta,r12
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       movb @vdpsta,@vdp_status
       b    *r11
*// vsync

*********************************************************************************
*
* Set name table
*
set_name_table:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @scrly,r0                  ; Get scroll offset
       coc  @eight,r0                  ; Check which table set to use
       jeq  set_name_table_2
       coc  @one,r0                    ; Check which table to use
       jeq  set_name_table_1
       li   r0, >020a                  ; namet1
       jmp  set_name_table_4
set_name_table_1:
       li   r0, >020b                  ; namet2
       jmp  set_name_table_4
set_name_table_2:
       coc  @one, r0                   ; Check which table to use
       jeq  set_name_table_3
       li   r0, >020c                  ; namet3
       jmp  set_name_table_4
set_name_table_3:
       li   r0, >020d                  ; namet4
*	   Update register 2
set_name_table_4:
       bl   @vwtr
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// set_name_table

*********************************************************************************
*
* Set sprite table
*
set_sprite_table:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @sprite_table_flag,r0
       andi r0,1
       ori  r0,>0500+(sprat1/>80)
       bl   @vwtr
       inv  @sprite_table_flag
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// set_sprite_table

*********************************************************************************
*
* User input
*
user_input:
       li   r1,sprite_player
       clr  @sprite_vx(r1)
       clr  @sprite_vy(r1)
*      Read joystick #1 using CRU
       li   r12,>0024                  ; CRU address of the column decoder
       li   r0,>0600                   ; Column 6, i.e joystick #1
       ldcr r0,3                       ; Select it
       li   r12,>0006                  ; Base CRU address for joystick 1
*      Fire
       tb   0
       jeq  user_input_0
       mov  @player_fire,r0
       jgt  user_input_1
       seto @player_fire
       jmp  user_input_1
user_input_0:
       clr  @player_fire
user_input_1:
*      Left
       tb   1
       jeq  user_input_2
       li   r0,>fe80
       mov  r0,@sprite_vx(r1)
       jmp  user_input_3
user_input_2:
*      Right
       tb   2
       jeq  user_input_3
       li   r0,>0180
       mov  r0,@sprite_vx(r1)
user_input_3:
*      Down
       tb   3
       jeq  user_input_4
       li   r0,>0180
       mov  r0,@sprite_vy(r1)
       jmp  user_input_5
user_input_4:
*      Up
       tb   4
       jeq  user_input_5
       li   r0,>fe80
       mov  r0,@sprite_vy(r1)
user_input_5:
       b    *r11
*// user_input

*********************************************************************************
*
* Fire weapons
*
fire:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @player_fire,r0
       jgt  fire_1
       jeq  fire_1
       bl   @add_bullet_sprite
       neg  @player_fire
*      Return
fire_1:
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// fire

*********************************************************************************
*
* Add sprites
*
add_sprites:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @sprite_pos_ptr,r8
       mov  *r8,r0
       jlt  add_sprites_1
       s    @scrly_current,r0
       jlt  add_sprites_1
       mov  @sprite_pos_def(r8),r0
       bl   @alloc_sprite
       mov  r1,r1
       jeq  add_sprites_1
*      Init x
       mov  @sprite_pos_x(r8),r0       ; Init x
       ai   r0,x_min
       sla  r0,8
       mov  r0,@sprite_x(r1)
*      Init y
       mov  @sprite_pos_y(r8),r0
       sla  r0,8
       mov  r0,@sprite_y(r1)           ; Init y
*      Record scroll position
       mov  @scrly_current,@sprite_scroll_y(r1)
*      Init path
       mov  @sprite_pos_path(r8),r2
       jeq  add_sprites_2
       mov  r2,@sprite_path(r1)               ; Init path pointer
       mov  @path_count(r2),@sprite_count(r1) ; Init counter
add_sprites_2:
*      Branch to custom initialisation routine
       mov  @sprite_def(r1),r2
       mov  @sprite_def_type(r2),r2
       sla  r2,1
       mov  @add_sprite_jump_table(r2),r0
       jeq  add_sprites_3
       bl   *r0
*      Next item in list
add_sprites_3:
       li   r0,sprite_pos_struct_size
       a    r0,@sprite_pos_ptr
*      Return
add_sprites_1:
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
add_sprite_jump_table:
       data 0                          ; Player
       data 0                          ; Bullet
       data 0                          ; Turret
       data 0                          ; Enemy bullet
       data add_enemy_plane_sprite     ; Enemy plane
       data add_tank_sprite            ; Tank
*// add_sprites

*********************************************************************************
*
* Add enemy plane sprite
*
add_enemy_plane_sprite:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @sprite_hw_2(r1),r2
       li   r0,>0100
       mov  r0,@hw_sprite_color(r2)
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// add_enemy_plane_sprite

*********************************************************************************
*
* Add tank sprite
*
add_tank_sprite:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @sprite_hw_1(r1),r2        ; Get turret sprite
       li   r0,1
       mov  r0,@hw_sprite_priority(r2) ; Medium priority
       mov  @sprite_hw_2(r1),r2        ; Get chassis sprite
       li   r0,>0e00
       mov  r0,@hw_sprite_color(r2)
       li   r0,>1c00
       mov  r0,@hw_sprite_pattern(r2)
*      Create a mask sprite
       mov  @sprite_x(r1),r0
       ci   r0,(x_min-16)*256
       jne  add_tank_sprite_1
       mov  r1,r8
       li   r0,sprite_def_mask
       bl   @alloc_sprite
       mov  r1,r1
       jeq  add_tank_sprite_1
       mov  @sprite_x(r8),@sprite_x(r1)
       mov  @sprite_y(r8),r0
       srl  r0,8
       a    @sprite_scroll_y(r8),r0
       mov  r0,@sprite_scroll_y(r1)
       mov  @sprite_hw_1(r1),r2
       clr  @hw_sprite_priority(r2)    ; Highest priority
       li   r0,16
       mov  r0,@sprite_count(r1)
*      Return
add_tank_sprite_1:
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// add_tank_sprite

*********************************************************************************
*
* Add bullet sprite
*
add_bullet_sprite:
       mov  r11,*r10+                  ; Push return address onto the stack
       li   r0,sprite_def_bullet
       bl   @alloc_sprite
       mov  r1,r1
       jeq  add_bullet_sprite_1
       li   r2,sprite_player
       mov  @sprite_x(r2),@sprite_x(r1)
       mov  @sprite_y(r2),r0
       ai   r0,>f000
       mov  r0,@sprite_y(r1)
       clr  @sprite_vx(r1)
       li   r0,>fc00
       mov  r0,@sprite_vy(r1)
*      Return
add_bullet_sprite_1:
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// add_bullet_sprite

*********************************************************************************
*
* Add bullet sprite
*
* r3: parent sprite
* @angle: angle of player relative to sprite
*
* Modifies r0-r1, r4-r7
*
add_enemy_bullet_sprite:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  r2,*r10+                   ; Push r2
       mov  r3,*r10+                   ; Push r3
       li   r0,sprite_def_enemy_bullet
       bl   @alloc_sprite
       dect r10                        ; Pop r3
       mov  *r10,r3
       mov  r1,@sprite_link(r3)        ; Link bullet to parent sprite
       jeq  add_enemy_bullet_1         ; If bullet could not be created
       mov  r3,@sprite_link(r1)        ; Link parent sprite to bullet
       mov  @sprite_x(r3),@sprite_x(r1)
       mov  @sprite_y(r3),@sprite_y(r1)
*      Direction
       mov  @angle,r2
       sla  r2,2
       mov  @unit_vectors(r2),r0
       sla  r0,1
       mov  r0,@sprite_vx(r1)
       mov  @unit_vectors+2(r2),r0
       sla  r0,1
       mov  r0,@sprite_vy(r1)
       mov  @scrly,@sprite_scroll_y(r1)
add_enemy_bullet_1:
       dect r10                        ; Pop r2
       mov  *r10,r2
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// add_enemy_bullet_sprite

*********************************************************************************
*
* Update sprites
*
update_sprites:
       mov  r11,*r10+                  ; Push return address onto the stack
       li   r2,n_sprites
       li   r3,sprites
update_sprites_1:
       mov  *r3,r1                     ; Get sprite definition
       jeq  update_sprites_2
       mov  @sprite_def_type(r1),r1    ; Get sprite type
       sla  r1,1
       mov  @update_sprite_jump_table(r1),r0
       jeq  update_sprites_2
       bl   *r0
update_sprites_2:
       ai   r3,sprite_struct_size
       dec  r2
       jne  update_sprites_1
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
update_sprite_jump_table:
       data update_player_sprite
       data update_bullet_sprite
       data update_turret_sprite
       data update_enemy_bullet_sprite
       data update_enemy_plane_sprite
       data update_tank_sprite
       data update_mask_sprite
*// update_sprites

*********************************************************************************
*
* Update player sprite
*
update_player_sprite:
*      Move
       mov  @sprite_vx(r3),r0
       jgt  update_player_sprite_1
       jlt  update_player_sprite_2
*      Center
       clr  r1
       jmp  update_player_sprite_4
*      Right
update_player_sprite_1:
       li   r1,>1000
       mov  @sprite_x(r3),r0
       ci   r0,(x_max-16)*256
       jl   update_player_sprite_3
       jmp  update_player_sprite_4
*      Left
update_player_sprite_2:
       li   r1,>0800
       mov  @sprite_x(r3),r0
       ci   r0,x_min*256
       jh   update_player_sprite_3
       jmp  update_player_sprite_4
update_player_sprite_3:
       a    @sprite_vx(r3),@sprite_x(r3)
update_player_sprite_4:
       mov  @sprite_vy(r3),r0
       jgt  update_player_sprite_5
       mov  @sprite_y(r3),r0
       jeq  update_player_sprite_6
       jmp  update_player_sprite_7
update_player_sprite_5:
       mov  @sprite_y(r3),r0
       ci   r0,>b000
       jhe  update_player_sprite_6
update_player_sprite_7:
       a    @sprite_vy(r3),@sprite_y(r3)
*      Update patterns
update_player_sprite_6:
       mov  @sprite_hw_1(r3),r4
       mov  r1,@hw_sprite_pattern(r4)
       mov  @sprite_hw_3(r3),r4
       mov  r1,@hw_sprite_pattern(r4)
       ai   r1,>0400
       mov  @sprite_hw_2(r3),r4
       mov  r1,@hw_sprite_pattern(r4)
*      Return
       b    *r11
*// update_player_sprite

*********************************************************************************
*
* Update bullet sprite
*
update_bullet_sprite:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @sprite_y(r3),r0
       ci   r0,>f000
       jh   update_bullet_sprite_1
       ci   r0,>c000
       jl   update_bullet_sprite_1
*      Remove
       mov  r3,r1
       bl   @dealloc_sprite
       jmp  update_bullet_sprite_1
*      Move
update_bullet_sprite_1:
       a    @sprite_vy(r3),@sprite_y(r3)
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// update_bullet_sprite

*********************************************************************************
*
* Update turret sprite
*
update_turret_sprite:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @sprite_scroll_y(r3),r0
       s    @scrly_current,r0          ; Move with scroll
       ai   r0,-16                     ; 16 lines y offset
       ci   r0,192                     ; Check for out of screen
       jgt  update_turret_sprite_1     ; Remove if out of screen
*      Move
       sla  r0,8
       mov  r0,@sprite_y(r3)           ; Set y
       ci   r0,>f000
       jhe  update_turret_sprite_2
*      Pattern
       bl   @get_angle
       movb @angle+1,r0                ; Get angle in MSB
       andi r0,>1c00                   ; Isolate octant
       ai   r0,>6000                   ; Add pattern base
       mov  @sprite_hw_1(r3),r1        ; Get hardware sprite
       movb r0,@hw_sprite_pattern(r1)  ; Set pattern
*      Create bullet
       mov  @sprite_link(r3),r0
       jne  update_turret_sprite_2
       bl   @add_enemy_bullet_sprite
       jmp  update_turret_sprite_2
*      Remove
update_turret_sprite_1:
       mov  @sprite_link(r3),r1        ; Get bullet linked to turret
       jeq  update_turret_sprite_3     ; Skip if none
       clr  @sprite_link(r1)           ; Unlink bullet from turret
update_turret_sprite_3:
       mov  r3,r1
       bl   @dealloc_sprite            ; Deallocate turret
update_turret_sprite_2:
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// update_turret_sprite

*********************************************************************************
*
* Update enemy bullet sprite
*
update_enemy_bullet_sprite:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Check bounds
       mov  @sprite_x(r3),r0
       ci   r0,x_min*256
       jl   update_enemy_bullet_sprite_2
       ci   r0,(x_max-2)*256
       jhe  update_enemy_bullet_sprite_2
       mov  @sprite_y(r3),r0
       ci   r0,>f000
       jh   update_enemy_bullet_sprite_1
       ci   r0,>c000
       jl   update_enemy_bullet_sprite_1
*      Remove
update_enemy_bullet_sprite_2:
       mov  @sprite_link(r3),r1        ; Get sprite that fired bullet
       jeq  update_enemy_bullet_sprite_4 ; Skip if none
       clr  @sprite_link(r1)           ; Remove link to bullet
update_enemy_bullet_sprite_4:
       mov  r3,r1
       bl   @dealloc_sprite            ; Deallocate bullet
       jmp  update_enemy_bullet_sprite_3
*      Move
update_enemy_bullet_sprite_1:
       a    @sprite_vx(r3),@sprite_x(r3)
       a    @sprite_vy(r3),@sprite_y(r3)
*      Move with scroll
       mov  @sprite_scroll_y(r3),r0
       s    @scrly,r0
       jeq  update_enemy_bullet_sprite_3
       sla  r0,8
       a    r0,@sprite_y(r3)
       mov  @scrly,@sprite_scroll_y(r3)
*      Return
update_enemy_bullet_sprite_3:
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// update_enemy_bullet_sprite

*********************************************************************************
*
* Update enemy plane sprite
*
update_enemy_plane_sprite:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Manage path
       mov  @sprite_path(r3),r4          ; Get path pointer
       dec  @sprite_count(r3)            ; Count down
       jgt  update_enemy_plane_sprite_4
*      Next path segment
       ai   r4,path_struct_size          ; Move pointer
       mov  @path_count(r4),r0           ; Get count for new segment
       jlt  update_enemy_plane_sprite_1  ; Negative means end
       mov  r0,@sprite_count(r3)         ; Save new count
       mov  r4,@sprite_path(r3)          ; Save updated path pointer
update_enemy_plane_sprite_4:
*      Check bounds
       mov  @sprite_x(r3),r0
       ci   r0,x_min*256
       jl   update_enemy_plane_sprite_1
       ci   r0,(x_max-2)*256
       jhe   update_enemy_plane_sprite_1
*      Move
       a    @path_vx(r4),@sprite_x(r3)
       a    @path_vy(r4),@sprite_y(r3)
*      Patterns
       mov  @sprite_hw_1(r3),r5
       mov  @path_pattern(r4),r0
       mov  r0,@hw_sprite_pattern(r5)
       mov  @sprite_hw_2(r3),r5
       ai   r0,>2000
       mov  r0,@hw_sprite_pattern(r5)
*      Create bullet
       mov  @sprite_link(r3),r0
       jne  update_enemy_plane_sprite_2
       mov  @path_action(r4),r0
       jeq  update_enemy_plane_sprite_2
       bl   @rand
       ci   r0,>f000
       jl   update_enemy_plane_sprite_2
       bl   @get_angle
       bl   @add_enemy_bullet_sprite
       jmp  update_enemy_plane_sprite_2
*      Remove
update_enemy_plane_sprite_1:
       mov  r3,r1
       bl   @dealloc_sprite
update_enemy_plane_sprite_2:
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// update_enemy_plane_sprite

*********************************************************************************
*
* Update tank sprite
*
update_tank_sprite:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Manage path
       mov  @sprite_path(r3),r4        ; Get path pointer
       dec  @sprite_count(r3)          ; Count down
       jgt  update_tank_sprite_4
*      Next path segment
       ai   r4,path_struct_size        ; Move pointer
       mov  @path_count(r4),r0         ; Get count for new segment
       jlt  update_tank_sprite_1       ; Negative means end
       mov  r0,@sprite_count(r3)       ; Save new count
       mov  r4,@sprite_path(r3)        ; Save updated path pointer
update_tank_sprite_4:
*      Check bounds
       mov  @sprite_x(r3),r0
       ci   r0,(x_max-2)*256
       jhe  update_tank_sprite_1
*      Move
       a    @path_vx(r4),@sprite_x(r3)
       a    @path_vy(r4),@sprite_y(r3)
*      Move with scroll
       mov  @sprite_scroll_y(r3),r0
       s    @scrly,r0
       jeq  update_tank_sprite_3
       sla  r0,8
       a    r0,@sprite_y(r3)
       mov  @scrly,@sprite_scroll_y(r3)
*      Pattern
update_tank_sprite_3:
       bl   @get_angle
       movb @angle+1,r0                ; Get angle in MSB
       andi r0,>1c00                   ; Isolate octant
       ai   r0,>a000                   ; Add pattern base
       mov  @sprite_hw_1(r3),r1        ; Get hardware sprite
       movb r0,@hw_sprite_pattern(r1)  ; Set pattern
*      Create bullet
       mov  @sprite_link(r3),r0
       jne  update_tank_sprite_2
       mov  @path_action(r4),r0
       jeq  update_tank_sprite_2
       bl   @add_enemy_bullet_sprite
       jmp  update_tank_sprite_2
*      Remove
update_tank_sprite_1:
       mov  r3,r1
       bl   @dealloc_sprite
update_tank_sprite_2:
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// update_tank_sprite

*********************************************************************************
*
* Update mask sprite
*
update_mask_sprite:
       mov  r11,*r10+                  ; Push return address onto the stack
       dec  @sprite_count(r3)
       jeq  update_mask_sprite_1
*      Move with scroll
       mov  @sprite_scroll_y(r3),r0
       s    @scrly_current,r0          ; Move with scroll
       ci   r0,192                     ; Check for out of screen
       jgt  update_mask_sprite_1       ; Remove if out of screen
*      Move
       sla  r0,8
       mov  r0,@sprite_y(r3)           ; Set y
       jmp  update_mask_sprite_2
*      Remove
update_mask_sprite_1:
       mov  r3,r1
       bl   @dealloc_sprite
update_mask_sprite_2:
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// update_mask_sprite


*********************************************************************************
*
* Get angle of player relative to sprite
*
* r3: points to sprite
*
* On return @angle contains the angle (0-31)
* Modifies r1, r5, r6
*
*
get_angle:
       li   r6,sprite_player
       mov  @sprite_y(r6),r0           ; Player y
       srl  r0,8
       mov  @sprite_y(r3),r5           ; Turret y
       srl  r5,8
       s    r5,r0                      ; Player y - turret y
       sra  r0,4                       ; / 16
       ai   r0,12                      ; + 12
       li   r1,19
       mpy  r1,r0                      ; * 19
       mov  @sprite_x(r6),r0           ; Player x
       srl  r0,8
       mov  @sprite_x(r3),r5           ; Turret x
       srl  r5,8
       s    r5,r0                      ; Player x - turret x
       sra  r0,4                       ; / 16
       ai   r0,9                       ; + 9
       a    r0,r1
       clr  @angle
       movb @angle_table(r1),@angle+1
       b    *r11
*// get_angle

*********************************************************************************
*
* Allocate sprite
*
* r0: Address of sprite definition
*
* On return r1 contains the address of the sprite,
* or 0 if the allocation failed.
*
* Modifies r0-r7
*
alloc_sprite:
       mov  r11,*r10+                  ; Push return address onto the stack
       li   r1,sprites
       li   r2,n_sprites
alloc_sprite_1:
       mov  *r1,r3
       jeq  alloc_sprite_2
       ai   r1,sprite_struct_size
       dec  r2
       jne  alloc_sprite_1
*      Failed
alloc_sprite_5:
       clr  r1
       jmp  alloc_sprite_3
*      Succeeded
alloc_sprite_2:
       mov  r0,r4
       mov  r4,*r1                     ; Set sprite definition
       clr  @sprite_link(r1)
       clr  @sprite_state(r1)
       mov  @sprite_def_size(r4),r5
       mov  r1,r6
       ai   r6,sprite_hw_1
alloc_sprite_4:
       bl   @alloc_hw_sprite
       mov  r0,r7
       jeq  alloc_sprite_5
       mov  r7,*r6+
       clr  @hw_sprite_dx(r7)
       clr  @hw_sprite_dy(r7)
       mov  @sprite_def_pattern(r4),@hw_sprite_pattern(r7)
       mov  @sprite_def_color(r4),@hw_sprite_color(r7)
       li   r0,2
       mov  r0,@hw_sprite_priority(r7)
       dec  r5
       jne  alloc_sprite_4
*      Return
alloc_sprite_3:
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// alloc_sprite

*********************************************************************************
*
* Allocate hardware sprite
*
* r1: Address of parent sprite
*
* On return r0 contain the address of the hw sprite,
* or 0 if the allocation failed.
*
* Modifies r2-r3
*
alloc_hw_sprite:
       li   r0,hw_sprites
       li   r2,n_hw_sprites
alloc_hw_sprite_1:
       mov  *r0,r3
       jeq  alloc_hw_sprite_2
       ai   r0,hw_sprite_struct_size
       dec  r2
       jne  alloc_hw_sprite_1
*      Failed
       clr  r0
       jmp  alloc_hw_sprite_3
*      Succeeded
alloc_hw_sprite_2:
       mov  r1,*r0
*      Record max hardware sprite
       neg  r2
       ai   r2,n_hw_sprites
       c    r2,@max_hw_sprite
       jlt  alloc_hw_sprite_3
       mov  r2,@max_hw_sprite
*      Return
alloc_hw_sprite_3:
       b    *r11
*// allow_hw_sprite

*********************************************************************************
*
* Deallocate sprite
*
* r1: Address of sprite
*
* Modifies r0-r1
*
dealloc_sprite:
       clr  *r1                        ; Clear reference to sprite definition
       mov  @sprite_hw_1(r1),r0        ; Get hardware sprite
       jeq  dealloc_sprite_1           ; Skip if not set
       clr *r0                         ; Clear reference to sprite
       clr  @sprite_hw_1(r1)           ; Clear reference to hardware sprite
dealloc_sprite_1:
       mov  @sprite_hw_2(r1),r0
       jeq  dealloc_sprite_2
       clr *r0
       clr  @sprite_hw_2(r1)
dealloc_sprite_2:
       mov  @sprite_hw_3(r1),r0
       jeq  dealloc_sprite_3
       clr *r0
       clr  @sprite_hw_3(r1)
dealloc_sprite_3:
       mov  @sprite_hw_4(r1),r0
       jeq  dealloc_sprite_4
       clr *r0
       clr  @sprite_hw_4(r1)
dealloc_sprite_4:
       li   r0,hw_sprite_struct_size
       mpy  @max_hw_sprite,r0
       ai   r1,hw_sprites              ; Address of max used hw sprite (before)
dealloc_sprite_5:
       mov  *r1,r0
       jne  dealloc_sprite_6
       dec  @max_hw_sprite
       ai   r1,-hw_sprite_struct_size
       ci   r1,hw_sprites
       jhe  dealloc_sprite_5
*      Return
dealloc_sprite_6:
       b    *r11
*// dealloc_sprite

*********************************************************************************
*
* Upload sprite attributes
*
upload_sprites:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Set destination address
       mov  @sprite_table_flag,r0
       andi r0,1
       sla  r0,7
       ai   r0,sprat1
       bl   @vwad
*      Init loop
       li   r15,vdpwd
       clr  r4                         ; Priority
       mov  @sprite_table_flag,r0
       jne  upload_sprites_1
       li   r6,hw_sprites              ; Start
       li   r5,hw_sprite_struct_size   ; Increment
       jmp  upload_sprites_2
upload_sprites_1:
       li   r5,hw_sprite_struct_size
       mpy  @max_hw_sprite,r5
       ai   r6,hw_sprites
       li   r5,-hw_sprite_struct_size
*      Loop
upload_sprites_2:
       mov  @max_hw_sprite,r2
       inc  r2
       mov  r6,r3                      ; Start address
upload_sprites_3:
       c    r4,@hw_sprite_priority(r3) ; Check priority
       jne  upload_sprites_4
       mov  *r3,r1                     ; Get parent sprite
       jeq  upload_sprites_4
       mov  @sprite_y(r1),r0
       a    @hw_sprite_dy(r3),r0
       movb r0,*r15
       mov  @sprite_x(r1),r0
       a    @hw_sprite_dx(r3),r0
       movb r0,*r15
       movb @hw_sprite_pattern(r3),*r15
       movb @hw_sprite_color(r3),*r15
upload_sprites_4:
       a    r5,r3
       dec  r2
       jne  upload_sprites_3
       inc  r4
       ci   r4,3
       jne  upload_sprites_2
*      End marker
       li   r0,>d000
       movb r0,*r15
*      Return
upload_sprites_5:
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// upload_sprites

*********************************************************************************
*
* Update character list
*
update_char_list:
       mov  @scrly,r0
       andi r0,7
       jne  update_char_list_5
       mov  @diff_ptr,r0
       clr  r1
*      Additions
       movb *r0+,r2                    ; Additions counter
       jeq  update_char_list_2
       srl  r2,8
update_char_list_1:
       movb *r0+,r1                    ; Char number
       srl  r1,7                       ; Char offset
       movb *r0+,r3                    ; Global char number MSB
       movb *r0+,@r3lb                 ; Global char number LSB
       sla  r3,4                       ; 16 bytes per pattern/color
       ai   r3,cart_base               ; Add cartridge base address
       mov  r3,@char_list(r1)          ; Store in character list
       dec  r2
       jne  update_char_list_1
*      Deletions
update_char_list_2:
       movb *r0+,r2                    ; Deletions counter
       jeq  update_char_list_4
       srl  r2,8
update_char_list_3:
       movb *r0+,r1                    ; Char number
       srl  r1,7                       ; Char offset
       seto @char_list(r1)             ; Mark as not used in character list
       dec  r2
       jne  update_char_list_3
update_char_list_4:
       mov  r0,@diff_ptr
*      Return
update_char_list_5:
       b    *r11
*// update_char_list

*********************************************************************************
*
* Update characters
*
update_characters:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @scrly,r3                  ; Read scroll offset into register
*	   Calculate VDP RAM destination address
       coc  @one,r3                    ; Check which character set to update
       jeq  update_low_chars
       li   r6,>400                    ; Update high character set (128-255)
       jmp  update_characters_1
update_low_chars:
       clr  r6                         ; Update low character set (128-255)
update_characters_1:
*	   Calculate CPU RAM source offset
       mov  r3,r1                      ; Start with scroll offset
       dec  r1                         ; Add direction
       andi r1,>0007                   ; Mod 8
*      Upload characters
       li   r15,vdpwd
       li   r14,vdpwa
       li   r13,8
*      Patterns
       mov  @cart_pattern_bank,r5
       seto *r5
       li   r0,ptrntb
       a    r6,r0
       bl   @vwad
       bl   @upload_character_table_pad
       bl   @interrupt_check
       li   r0,ptrntb+>800
       a    r6,r0
       bl   @vwad
       bl   @upload_character_table_pad
       bl   @interrupt_check
       li   r0,ptrntb+>1000
       a    r6,r0
       bl   @vwad
       bl   @upload_character_table_pad
       bl   @interrupt_check
*      Colors
       mov  @cart_color_bank,r5
       seto *r5
       li   r0,colrtb
       a    r6,r0
       bl   @vwad
       bl   @upload_character_table_pad
       bl   @interrupt_check
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// update_characters

*********************************************************************************
*
* Upload character table
*
* R13: Offset between characters (8)
* R14: vdpwa
* R15: vdpwd
*

upload_character_table:
       mov  @max_chars,r2              ; Char counter
       li   r3,char_list
upload_character_table_1:
       mov  *r3+,r4                    ; Get pattern address
       jlt  upload_character_table_2   ; If negative, characeter is not used
       a    r1,r4                      ; Add source offset
       movb *r4+,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       a    r13,r0
       dec  r2
       jne  upload_character_table_1
       b    *r11
upload_character_table_2:
       a    r13,r0
       movb @r0lb,*r14                 ; Send low byte of VDP RAM write address
       movb r0,*r14                    ; Send high byte of VDP RAM write address
       dec  r2
       jne  upload_character_table_1
       b    *r11
upload_character_table_end
*// upload_character_table

*********************************************************************
*
* Update name table off-screen buffer
*
update_name_table:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @scrly,r3                  ; Get scroll frame (0-15)
       andi r3,>000f
*	   Calculate row offset to the 1/4 of the buffer to update
       mov  r3,r0                      ; Start with frame number
       andi r0,>0006                   ; Transform to sequence: 0,0,2,2,4,4,6,6...
       mov  r0,r2                      ; Copy to R2
       sla  r0,1                       ; Multiply by 2
       a    r0,r2                      ; Add to R2 to multiply by 6 and get row offset: 0,0,6,6,12,12,18,18...
       mov  r2,r0                      ; Copy back into R0 for later
*	   Calculate map source address in R1
       mov  @scrly,r1                  ; Get scroll offset in pixels
       sra  r1,3                       ; Divide by 8 to get row offset
       a    r2,r1                      ; Add the row offset we calculated before
       li   r2,map_width
       mpy  r2,r1                      ; Multiply by map width to get character offset
       li   r1,cart_base               ; Get the map base address
       a    r2,r1                      ; Add the character offset
*	   Calculate buffer destination address in R0
       sla  r0,5                       ; Convert row offset to character offset
       ai   r0,map_left
*	   Decide which buffer to update
       coc  @eight,r3                  ; Bit weight >08 determines the group
       jne  update_name_table_2        ; If not set we update buffer 2 or 3
       coc  @one,r3                    ; Bit weight >01 determines the buffer
       jeq  update_name_table_1
       ai   r0,namet1                  ; Add base address to character offset
       mov  @cart_map_bank,r5
       jmp  update_name_table_4
update_name_table_1:
       ai   r0,namet2                  ; Add base address to character offset
       mov  @cart_map_high_bank,r5
       jmp  update_name_table_4
update_name_table_2:
       coc  @one,r3                    ; Bit weight >01 determines the buffer
       jeq  update_name_table_3
       ai   r0,namet3                  ; Add base address to character offset
       mov  @cart_map_bank,r5
       jmp  update_name_table_4
update_name_table_3:
       ai   r0,namet4                  ; Add base address to character offset
       mov  @cart_map_high_bank,r5
update_name_table_4:
       seto *r5                        ; Select map cartridge bank
*	   Copy to VDP RAM buffer
       li   r15,vdpwd
       li   r2,6
update_name_table_5:
       bl   @vwad
       li   r3,win_width/6
update_name_table_6:
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       dec  r3
       jne  update_name_table_6
;      bl   @interrupt_check
       ai   r0,scr_width               ; Next VDP row
       dec  r2
       jne  update_name_table_5
*	   Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// update_name_table

*********************************************************************************
*
* Draw initial screen
*
draw_initial_screen:
       mov  r11, *r10+                  ; Push return address onto the stack
       li   r15,vdpwd
*      Source address
       mov  @scrly,r1
       srl  r1,3
       li   r0,map_width
       mpy  r1,r0
       ai   r1,cart_base
       mov  r1,r4
*      Map
       li   r0,namet3+map_left
       li   r2,win_height
       mov  @cart_map_bank,r5
       seto *r5
draw_screen_1:
       bl   @vwad
       li   r3,win_width
draw_screen_2:
       movb *r1+,*r15
       dec  r3
       jne  draw_screen_2
       ai   r0,scr_width
       dec  r2
       jne  draw_screen_1
*      Map - high
       li   r0,namet4+map_left
       mov  r4,r1
       li   r2,win_height
       mov  @cart_map_high_bank,r5
       seto *r5
draw_screen_3:
       bl   @vwad
       li   r3,win_width
draw_screen_4:
       movb *r1+,*r15
       dec  r3
       jne  draw_screen_4
       ai   r0,scr_width
       dec  r2
       jne  draw_screen_3
*      Update chars
       inc  @scrly
       bl   @update_char_list
       dec  @scrly
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// draw_initial_screen

*********************************************************************************
*
* Initialize level
*
init_level:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Init variables
       mov  @level,r1
       sla  r1,1
       mov  @map_heights(r1),@map_height
       mov  @map_height,r0
       ai   r0,-win_height
       sla  r0,3
       mov  r0,@scrly
       mov  r0,@scrly_current
       mov  @diff_lists(r1),r0
       clr  @max_chars
       movb *r0+,@max_chars+1
       mov  r0,@diff_ptr
       mov  @sprite_pos_lists(r1),@sprite_pos_ptr
*      Cartridge addresses
       mov  @level,r1
       sla  r1,3
       ai   r1,>6008
       mov  r1,@cart_pattern_bank
       inct r1
       mov  r1,@cart_color_bank
       inct r1
       mov  r1,@cart_map_bank
       inct r1
       mov  r1,@cart_map_high_bank
*      Reset character list
       li   r0,char_list
       li   r2,128
init_level_1:
       seto *r0+
       dec  r2
       jne  init_level_1
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// init_scrbuf

*********************************************************************************
*
* One time initializations
*
init:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Init variables
       li   r0,1
       mov  r0,@one
       li   r0,8
       mov  r0,@eight
       li   r0,start_level
       mov  r0,@level
       clr  @sprite_table_flag
*      Init sprites
       li   r0,sprites+(1*sprite_struct_size)
       li   r2,(n_sprites-1)*sprite_struct_size
       bl   @clear_memory
       li   r0,hw_sprites+(3*hw_sprite_struct_size)
       li   r2,(n_hw_sprites-3)*hw_sprite_struct_size
       bl   @clear_memory
*      Init player sprite
       li   r0,sprite_def_player
       bl   @alloc_sprite
       li   r0,(x_min+((x_max-x_min)/2)-8)*256
       movb r0,@sprite_x(r1)
       li   r0,>9f00
       movb r0,@sprite_y(r1)
       clr  @sprite_vx(r1)
       clr  @sprite_vy(r1)
       li   r0,>0100
       mov  @sprite_hw_2(r1),r2
       mov  r0,@hw_sprite_color(r2)
       mov  @sprite_hw_3(r1),r2
       mov  r0,@hw_sprite_color(r2)
       li   r0,>0e00
       mov  r0,@hw_sprite_dx(r2)
       li   r0,>1000
       mov  r0,@hw_sprite_dy(r2)
*      Copy code to pad
       li   r0,upload_character_table
       li   r1,upload_character_table_pad
       li   r2,upload_character_table_end-upload_character_table
       bl   @copy_memory
*      Draw panel
       li   r0,panel_left*256
       li   r1,MD0
       li   r2,12
       li   r3,24
       li   r4,0
       bl   @draw_box
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// init

*********************************************************************
*
* Clear memory
*
* R0: Start address
* R2: Length
*
clear_memory:
       clr  *r0+
       dect r2
       jne  clear_memory
       b    *r11
*// clear_memory

*********************************************************************
*
* Copy memory
*
* R0: Source address
* R1: Destination address
* R2: Length
*
copy_memory:
       mov  *r0+,*r1+
       dect r2
       jne  copy_memory
       b    *r11
*// copy_memory

*********************************************************************************
*
* Set graphics mode
*
gmode:
       mov  r11,*r10+                  ; Push return address onto the stack
       clr  r0
       li   r1,vregs
       li   r2,8
gmode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  gmode_1
*      Patterns
       seto @>6008
       li   r0,ptrntb
       clr  r1
       li   r2,>800
       bl   @vdpwr
       li   r0,8*112+ptrntb
       li   r1,PAT112
       li   r2,16*8
       bl   @vdpcp
       li   r0,8*112+ptrntb+>800
       li   r1,PAT112
       li   r2,16*8
       bl   @vdpcp
       li   r0,8*112+ptrntb+>1000
       li   r1,PAT112
       li   r2,16*8
       bl   @vdpcp
       li   r0,8*240+ptrntb
       li   r1,PAT240
       li   r2,16*8
       bl   @vdpcp
       li   r0,8*240+ptrntb+>800
       li   r1,PAT240
       li   r2,16*8
       bl   @vdpcp
       li   r0,8*240+ptrntb+>1000
       li   r1,PAT240
       li   r2,16*8
       bl   @vdpcp
*      Colors
       seto @>600A
       li   r0,colrtb
       clr  r1
       li   r2,>800
       bl   @vdpwr
       li   r0,8*112+colrtb
       li   r1,COL112
       li   r2,16*8
       bl   @vdpcp
       li   r0,8*240+colrtb
       li   r1,COL240
       li   r2,16*8
       bl   @vdpcp
*      Name tables
       li   r0,namet1
       li   r1,>ff00
       li   r2,>1000
       bl   @vdpwr
*      Sprite patterns
       li   r0,sprptb
       li   r1,spr0
       li   r2,64*32
       bl   @vdpcp
*      Sprite attributes
       li   r0,sprat1
       li   r1,>d000
       bl   @vsbw
       li   r0,sprat2
       li   r1,>d000
       bl   @vsbw
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*      VDP registers
vregs:
       byte >02                        ; Graphics II mode
       byte >e2                        ; 16K, display on, interrupt enabled
       byte namet1/>400                ; Name table
       byte >9f                        ; Color table
       byte ptrntb/>800+>03            ; Pattern table
       byte sprat1/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >01                        ; Backdrop color
*// gmode

*********************************************************************************
*
* Draw box to all name tables
*
* r0: col MSB, row LSB
* r1: source
* r2: width
* r3: height
* r4: source row offset
*
draw_box:
       mov  r11,*r10+                  ; Push return address onto the stack
       li   r15,vdpwd
       mov  r0,r5
       andi r0,>00ff
       sla  r0,5
       socb r5,@r0lb
       ai   r0,namet1
       mov  r0,r6
       mov  r1,r7
       mov  r2,r8
       mov  r3,r9
       li   r12,4
draw_box_1:
       mov  r9,r3
draw_box_2:
       bl   @vwad
       mov  r8,r2
draw_box_3:
       movb *r1+,*r15
       dec  r2
       jne  draw_box_3
       ai   r0,32
       a    r4,r1
       dec  r3
       jne  draw_box_2
       ai   r6,>400
       mov  r6,r0
       mov  r7,r1
       dec  r12
       jne  draw_box_1
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// draw_box

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB: VDP register to write to
* R0 LSB: Value to write
*
vwtr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte (value) to write to VDP register
       swpb r0
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       b    *r11
*// vwtr

*********************************************************************
*
* VDP Set Write Address
*
* R0: Write address in VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vwad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       b    *r11
*// vwad

*********************************************************************
*
* VDP Single Byte Read
*
* R0   Read address in VDP RAM
* R1   MSB of R1 set to byte from VDP RAM
*
vsbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb @vdprd,r1                  ; Read byte from VDP RAM
       b    *r11
*// vsbr

*********************************************************************
*
* VDP Single Byte Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsbw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,@vdpwd                  ; Write byte to VDP RAM
       b    *r11
*// vsbw

***************************************************************************
*
* VDP Multiple Byte Read
*
* R0: Starting read address in VDP RAM
* R1: Starting write address in CPU RAM
* R2: Number of bytes to read from VDP RAM
*
* Modifies R0-R2
*
vmbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vmbr0:
       li   r0,vdprd
vmbr1:
       movb *r0,*r1+                   ; Read byte from VDP RAM
       dec  r2                         ; Byte counter
       jne  vmbr1                      ; Check if finished
       b    *r11
*// vmbr

*********************************************************************
*
* Fast CPU to VDP copy, replaces VMBW
*
* R0: Destination address
* R1: Source address
* R2: Number of bytes to copy
*
vdpcp:
       mov  r11,*r10+                  ; Push return address onto the stack
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set the two MSbits to 01 for write
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdpwd
vdpcp0:
       mov  r2,r3
       srl  r3,3                       ; Number of groups of 8
       jeq  vdpcp2
vdpcp1:
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       dec  r3
       jne  vdpcp1
       andi r2,>0007                   ; Isolate number of remaining bytes
       jeq  vdpcp3
vdpcp2:
       movb *r1+,*r0
       dec  r2
       jne  vdpcp2
vdpcp3:
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// vdpcp

*********************************************************************
*
* Fast CPU to VDP write, replaces VSMW
*
* R0: Destination address
* R1: Byte to write in MSB
* R2: Number of bytes to copy
*
vdpwr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set the two MSbits to 01 for write
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdpwd
       mov  r2,r3
       srl  r3,3                       ; Number of groups of 8
       jeq  vdpwr2
vdpwr1:
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       dec  r3
       jne  vdpwr1
       andi r2,>0007                   ; Isolate number of remaining bytes
       jeq  vdpwr3
vdpwr2:
       movb r1, *r0
       dec  r2
       jne  vdpwr2
vdpwr3:
       b    *r11
*// vdpwr

*********************************************************************
*
* Random number generator
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0
       ai   r0,31873                   ; Add a prime number
       src  r0,7                       ; Shift to break odd/even pattern
       mov  r0,@rand_no
       b    *r11
*// rand

*********************************************************************
*
* Data
*
char_list:                             ; Pointers to pattern/color addresses for current characeter set
       bss  128*2                      ; Or -1 if the character is not currently used
map_heights:
       data 382, 450, 340, 364
**
* Sprite definitions
*
sprite_defs:
       equ  $
*      Player
sprite_def_player:
       data sprite_type_player         ; Type
       data >000f                      ; Width
       data >000c                      ; Height
       data >0000                      ; Left
       data >0001                      ; Top
       data >0003                      ; Size
       data >0000                      ; Pattern
       data >0f00                      ; Color
*      Bullet
sprite_def_bullet:
       data sprite_type_bullet         ; Type
       data >0004                      ; Width
       data >0004                      ; Height
       data >0006                      ; Left
       data >0009                      ; Top
       data >0001                      ; Size
       data >d000                      ; Pattern
       data >0f00                      ; Color
*      Gun turret
sprite_def_turret:
       data sprite_type_turret         ; Type
       data >000c                      ; Width
       data >000c                      ; Height
       data >0001                      ; Left
       data >0001                      ; Top
       data >0001                      ; Size
       data >6000                      ; Pattern
       data >0e00                      ; Color
*      Enemy bullet
sprite_def_enemy_bullet:
       data sprite_type_enemy_bullet   ; Type
       data >0004                      ; Width
       data >0004                      ; Height
       data >0006                      ; Left
       data >0009                      ; Top
       data >0001                      ; Size
       data >d000                      ; Pattern
       data >0f00                      ; Color
*      Enemy plane
sprite_def_enemy_plane:
       data sprite_type_enemy_plane    ; Type
       data >000e                      ; Width
       data >000c                      ; Height
       data >0001                      ; Left
       data >0002                      ; Top
       data >0002                      ; Size
       data >2000                      ; Pattern
       data >0800                      ; Color
*      Tank
sprite_def_tank:
       data sprite_type_tank           ; Type
       data >000e                      ; Width
       data >000c                      ; Height
       data >0001                      ; Left
       data >0002                      ; Top
       data >0002                      ; Size
       data >a800                      ; Pattern
       data >0100                      ; Color
*      Mask
sprite_def_mask:
       data sprite_type_mask           ; Type
       data >0010                      ; Width
       data >0010                      ; Height
       data >0000                      ; Left
       data >0000                      ; Top
       data >0001                      ; Size
       data >fc00                      ; Pattern
       data >0100                      ; Color
*      Sprites
sprites:
       bss n_sprites*sprite_struct_size
sprite_player:
       equ  sprites
* Hardware sprites
hw_sprites:
       bss  n_hw_sprites*hw_sprite_struct_size
**
* Character differences after each 8 pixels scrolled
*
diff_lists:
       data diff_list_1,diff_list_2,diff_list_3,diff_list_4
diff_list_1:
       copy "level1-diff.a99"
diff_list_2:
       copy "level2-diff.a99"
diff_list_3:
       copy "level3-diff.a99"
diff_list_4:
       copy "level4-diff.a99"
**
* Sprite and panel graphics
*
       copy "sprites.a99"
       copy "panel.a99"
**
* Sprite positions and paths
*
       copy "paths.a99"

       copy "geometry.a99"

       end  main
