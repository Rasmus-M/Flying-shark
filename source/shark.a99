*********************************************************************
*
* Flying Shark
* For the TI-99/4A home computer
*
* August 2017 - April 2018
* Rasmus Moustgaard <rasmus.moustgaard@gmail.com>
*
*********************************************************************

       def  main

**
* Assembly options
*
immunity:
       equ  0

**
* Constants
*
start_level:
       equ  0
start_lives:
       equ  3
start_bombs:
       equ  3
action_speed:
       equ >0080
scroll_interval:
       equ  4
player_speed:
       equ  >0200
title_bank:
       equ  >6008
levels_base_bank:
       equ  >600c
title_music_bank:
       equ  >606c
landing_music_bank:
       equ  >606e
cart_base:
       equ  >603c
cart_music_base:
       equ  >6400
scr_width:                             ; Width of screen in characters
       equ  32
scr_height:                            ; Height of screen in characters
       equ  24
win_width:                             ; Width of scrolling window in characters
       equ  18
win_height:                            ; Height of scrolling window in characters
       equ  24
map_width:                             ; Map width
       equ  18
map_left:                              ; Map start column
       equ  14
panel_left:                            ; Panel start column
       equ  0
panel_width:                           ; Panel width
       equ  12
x_min:                                 ; Minimum x position
       equ  map_left*8
x_max:                                 ; Maximum x position
       equ  (map_left+map_width)*8
n_sprites:                             ; Number of sprites
       equ  20
n_hw_sprites:                          ; Number of hardware sprites
       equ  48
chzero:                                ; Character code for zero
       equ  240
power_up_none:
       equ  0
power_up_double_shot:
       equ  1
power_up_triple_shot:
       equ  2
n_high_scores:
       equ  10

**
* Memory mapped addresses
*
vdpwd  equ  >8c00                      ; VDP write data
vdpwa  equ  >8c02                      ; VDP set read/write address
vdprd  equ  >8800                      ; VDP read data
vdpsta equ  >8802                      ; VDP status
sound  equ  >8400

**
* VDP memory map
*
ptrntb equ  >0000                      ; Pattern table base
sprptb equ  >1800                      ; Sprite pattern table base
colrtb equ  >2000                      ; Color table base
namet1 equ  >2800                      ; Name table base 1 >A
namet2 equ  >2c00                      ; Name table base 2 >B
namet3 equ  >3000                      ; Name table base 3 >C
namet4 equ  >3400                      ; Name table base 4 >D
sprat1 equ  >3700                      ; Sprite attribute table base 1
sprat2 equ  >3780                      ; Sprite attribute table base 2
namet5 equ  >3800                      ; Name table base 5
sprat3 equ  >3b00                      ; Sprite attribute table base 3

**
* Structures
*
* Sprite definition types
sprite_type_player:
       equ  0
sprite_type_bullet:
       equ  1
sprite_type_turret:
       equ  2
sprite_type_enemy_bullet:
       equ  3
sprite_type_enemy_plane:
       equ  4
sprite_type_tank:
       equ  5
sprite_type_mask:
       equ  6
sprite_type_power_up:
       equ  7
sprite_type_smart_bomb:
       equ  8
sprite_type_extra_life:
       equ  9
sprite_type_boss_tank:
       equ  10
sprite_type_boat:
       equ  11
sprite_type_big_plane:
       equ  12

* Sprite definition structure
sprite_def_type:                       ; Sprite type
       equ  0
sprite_def_width:                      ; Width
       equ  2
sprite_def_height:                     ; Height
       equ  4
sprite_def_left:                       ; Left
       equ  6
sprite_def_top:                        ; Top
       equ  8
sprite_def_size:                       ; Number of hw sprites
       equ  10
sprite_def_pattern:                    ; Base pattern
       equ  12
sprite_def_color:                      ; Base color
       equ  14
sprite_def_hits_left:                  ; Base hits left
       equ  16
sprite_def_hit_action:                 ; > 0 = deadly, < 0 = pickup
       equ  18
sprite_def_fire_rate:                  ; How often can the sprite fire?
       equ  20
sprite_def_struct_size:                ; Structure size
       equ  22

* Sprite structure
sprite_def:                            ; Pointer to sprite definition structure
       equ  0
sprite_x:                              ; x position
       equ  2
sprite_y:                              ; y position
       equ  4
sprite_vx:                             ; x velocity
       equ  6
sprite_vy:                             ; y velocity
       equ  8
sprite_hw_1:                           ; Hardware sprite 1
       equ  10
sprite_hw_2:                           ; Hardware sprite 2
       equ  12
sprite_hw_3:                           ; Hardware sprite 3
       equ  14
sprite_hw_4:                           ; Hardware sprite 4
       equ  16
sprite_hw_5:                           ; Hardware sprite 5
       equ  18
sprite_hw_6:                           ; Hardware sprite 6
       equ  20
sprite_hw_7:                           ; Hardware sprite 7
       equ  22
sprite_hw_8:                           ; Hardware sprite 8
       equ  24
sprite_link:                           ; Linked sprite
       equ  26
sprite_mask:                           ; Mask sprite
       equ  28
sprite_count:                          ; Counter
       equ  30
sprite_path:                           ; Path
       equ  32
sprite_hits_left:                      ; Hits left before sprite is destroyed
       equ  34
sprite_fire_delay:                     ; Count down until sprite can fire next
       equ  36
sprite_wave:                           ; Wave number
       equ  38
sprite_struct_size:                    ; Structure size
       equ  40

* Hardware sprite structure
hw_sprite:                             ; Pointer to sprite structure
       equ  0
hw_sprite_dx:                          ; Offset from sprite_x
       equ  2
hw_sprite_dy:                          ; Offset from sprite_y
       equ  4
hw_sprite_pattern:                     ; Pattern
       equ  6
hw_sprite_color:                       ; Color
       equ  8
hw_sprite_priority:                    ; Priority: 0, 1, 2 (0 highest)
       equ  10
hw_sprite_struct_size:                 ; Structure size
       equ  12

* Sprite position structure
sprite_pos_scroll_y:                   ; Scroll position when sprite appears
       equ  0
sprite_pos_x:                          ; X offset where sprite appears
       equ  2
sprite_pos_y:                          ; Y offset where sprite appears
       equ  4
sprite_pos_def:                        ; Sprite definition pointer
       equ  6
sprite_pos_path:                       ; Path pointer
       equ  8
sprite_pos_wave:                       ; Wave number
       equ  10
sprite_pos_struct_size:
       equ  12

* Wave structure
wave_left:                             ; Enemies left
       equ  0
wave_total:                            ; Enemies total
       equ  2
wave_bonus:                            ; Bonus type (see below)
       equ  4
wave_unused:
       equ  6
wave_size:
       equ  8

* Wave bonus
wave_bonus_none:
       equ  0
wave_bonus_power_up:
       equ  1
wave_bonus_smart_bomb:
       equ  2
wave_bonus_life:
       equ  3
wave_bonus_points:
       equ  4

* Path structure
path_count:
       equ  0
path_vx:
       equ  2
path_vy:
       equ  4
path_pattern:
       equ  6
path_action:
       equ  8
path_struct_size:
       equ  10
**
* Scratch pad
*
rndsd  equ  >83c0                      ; Random number seed
pad    equ  >8300
wrksp  equ  pad                        ; Workspace
r0lb   equ  wrksp+1                    ; r0 low byte required for VDP routines
r1lb   equ  wrksp+3
r2lb   equ  wrksp+5
r3lb   equ  wrksp+7
wrksp2 equ  pad+>20                    ; Interrupt routine work space
sndws  equ  wrksp2+>20                 ; Sound player work space
stack  equ  sndws+>20                  ; Stack (grows up)
padvar equ  stack+>20                  ; Start of pad variables
*
* PAD variables
*
one:                                   ; Constant 1
       equ  padvar
eight:                                 ; Constant 8
       equ  one+2
level:                                 ; Play level
       equ  eight+2
scroll_y:                              ; Vertical scroll offset (next)
       equ  level+2
scroll_y_current:                      ; Vertical scroll offset (current)
       equ  scroll_y+2
scroll_y_last:                         ; Vertical scroll offset (last)
       equ  scroll_y_current+2
scroll_y_diff:                         ; Difference in scroll offset from last
       equ  scroll_y_last+2
scroll_y_max:                          ; Vertical scroll offset (current)
       equ  scroll_y_diff+2
take_off_end:                          ; Scroll offset where takeoff will end
       equ  scroll_y_max+2
landing_start:                         ; Scroll offser where landing will start
       equ  take_off_end+2
map_height:                            ; Height of current level in characters
       equ  landing_start+2
diff_ptr:                              ; Pointer to difference list
       equ  map_height+2
max_chars:                             ; Maximum characters used for map
       equ  diff_ptr+2
cart_pattern_bank:                     ; ROM bank holding patterns
       equ  max_chars+2
cart_map_bank:                         ; ROM bank holding map
       equ  cart_pattern_bank+2
cart_map_high_bank:                    ; ROM bank holding map with msb set
       equ  cart_map_bank+2
cart_diff_bank:                        ; ROM bank holding difference list
       equ  cart_map_high_bank+2
cart_music_bank:                       ; ROM bank holding music
       equ  cart_diff_bank+2
frame_count:                           ; Frame counter
       equ  cart_music_bank+2
vdp_status:                            ; VDP status
       equ  frame_count+2
user_input_enabled:                    ; Is user input (joystick) enabled?
       equ  vdp_status+2
user_input_device:                     ; 0=Keyboard, 1=Joystick
       equ  user_input_enabled+2
player_fire:                           ; 0=Released, 1=Pressed - not ready, -1=Pressed - ready
       equ  user_input_device+2
sprite_pos_ptr:                        ; Pointer to sprite position list
       equ  player_fire+2
sprite_table_flag:                     ; Which VDP aprite attriutes table to use
       equ  sprite_pos_ptr+2
angle:                                 ; Angle of enemy relative to player
       equ  sprite_table_flag+2
max_sprite:                            ; Maximum used sprite number
       equ  angle+2
max_hw_sprite:                         ; Maximum user hardware sprite number
       equ  max_sprite+2
sprite_counter:                        ; Sprite loop counter
       equ  max_hw_sprite+2
rand_no:                               ; Last random number
       equ  sprite_counter+2
score_msw:                             ; Low word of score
       equ  rand_no+2
score_lsw:                             ; High word of score
       equ  score_msw+2
lives:                                 ; Lives left
       equ  score_lsw+2
status:                                ; 0 = normal, -1 = died, 1 = won
       equ  lives+2
power_ups:                             ; Power-up status
       equ  status+2
smart_bombs:                           ; Smart bombs left
       equ  power_ups+2
bomb_count_down:                       ; Timing of smart bomb
       equ  smart_bombs+2
music:                                 ; Pointer to music
       equ  bomb_count_down+2
upload_character_table_pad:            ; Code in pad
       equ  music+2
pad_max:
       equ  upload_character_table_pad+52

********************************************************************************
*
* Main program
*
       aorg >a000
main:
       limi 0                          ; Interrupts off
       lwpi wrksp                      ; Setup workspace
       li   r10,stack                  ; Setup stack pointer
       mov  @rndsd,@rand_no            ; Save random number seed
       bl   @init                      ; One time initializations
new_game:
       bl   @title_screen              ; Display title screen
       bl   @gmode                     ; Setup graphics mode
       bl   @init_game                 ; Initialize game
next_level:
       bl   @init_level                ; Initialize level
restart:
       bl   @display_get_ready
main_loop:
       clr  @frame_count               ; Counter for number of frames used
       bl   @game_frame_actions        ; Update sprites according to input
       movb @vdpsta,@vdp_status        ; Check for interrupt and clear if set
       jgt  main_set_tables            ; No interrupt - skip
       jeq  main_set_tables            ; No - skip (required on F18A)
       bl   @play_sound                ; Play if interrupt has occurred
*      Change VDP tables at vsync
main_set_tables:
       bl   @vsync                     ; Wait for next vsync/interrupt
       bl   @set_name_table            ; Flip name table double buffer
       bl   @set_sprite_table          ; Flip sprite table double buffer
       bl   @play_sound                ; Play sound/music
*      Check status
       mov  @status,r0
       jlt  main_died
*      Scroll the background
       bl   @update_char_list          ; Determine which characters to update
       bl   @update_characters         ; Update characters
       bl   @update_name_table         ; Update name table double buffer
*      Delay
       li   r2,scroll_interval         ; Frames per scroll
       s    @frame_count,r2            ; Subtract frame used
       jlt  !                          ; Used too many already?
       jeq  !                          ; Used all?
main_delay:
       bl   @vsync                     ; Wait for vsync/interrupt
       bl   @interrupt_routine         ; Exec game actions and play music
       dec  r2                         ; Delay counter
       jne  main_delay                 ; Delay loop
*      Change scroll position
!      mov  @scroll_y,@scroll_y_current   ; Set scroll position as current
       dec  @scroll_y                  ; Change scroll position for net frame
       jne  main_loop                  ; Loop if not at top
*      Next level
       li   r3,16
main_next:
       li   r2,624/16
       bl   @wait
       li   r0,250
       bl   @add_score
       dec  r3
       jne  main_next
       inc  @level                     ; Increase level
       li   r0,>fffc                   ; Mask
       szc  r0,@level                  ; Level mod 4
       jmp  next_level                 ; Level loop
main_died:
       dec  @lives
       bl   @display_lives
       mov  @lives,r0
       jne  !
       bl   @game_over
       jmp  new_game
!      bl   @died
       jmp  restart
*// main

********************************************************************************
*
* "Interrupt routine"
*
* Changes r12 of calling workspace
*
interrupt_check:
       clr  r12
       tb   2                          ; Did an interrupt occur?
       jeq  interrupt_routine_end      ; No - jump
       movb @vdpsta,@vdp_status
*      Interrupt occurred
interrupt_routine:
       mov  r10,@wrksp2+20             ; Use same SP in new workspace
       lwpi wrksp2                     ; Switch to new workspace
       bl   @play_sound
       bl   @game_frame_actions
       bl   @set_sprite_table
       lwpi wrksp                      ; Switch to old workspace
interrupt_routine_end:
       b    *r11
*// interrupt_check

*********************************************************************
*
* Game frame actions
*
game_frame_actions:
       mov  r11,*r10+
       mov  @frame_count,r0
       andi  r0,>0001
       jne  game_frame_actions_1
*      Every 2nd frame
       bl   @user_input
       bl   @fire
       bl   @smart_bomb
       bl   @add_sprites
       bl   @update_sprites
       mov  @frame_count,r0
       andi  r0,>0003
       jne  game_frame_actions_1
*      Every 4th frame
       bl   @sprite_collisions
*      Every frame
game_frame_actions_1:
       bl   @upload_sprites
       inc  @frame_count
*      Return
       dect r10
       mov  *r10,r11
       b    *r11
*// game_frame_actions

*********************************************************************
*
* Wait for vertical retrace (CRU)
*
vsync:
       clr  r12
vsync_1:
       tb   2                          ; Test CRU bit for VDP interrupt
       jeq  vsync_1
       movb @vdpsta,@vdp_status
       b    *r11
*// vsync

*********************************************************************************
*
* Set name table
*
set_name_table:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @scroll_y,r0               ; Get scroll offset
       coc  @eight,r0                  ; Check which table set to use
       jeq  set_name_table_2
       coc  @one,r0                    ; Check which table to use
       jeq  set_name_table_1
       li   r0, >020a                  ; namet1
       jmp  set_name_table_4
set_name_table_1:
       li   r0, >020b                  ; namet2
       jmp  set_name_table_4
set_name_table_2:
       coc  @one, r0                   ; Check which table to use
       jeq  set_name_table_3
       li   r0, >020c                  ; namet3
       jmp  set_name_table_4
set_name_table_3:
       li   r0, >020d                  ; namet4
*       Update register 2
set_name_table_4:
       bl   @vwtr
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// set_name_table

*********************************************************************************
*
* Set sprite table
*
set_sprite_table:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @sprite_table_flag,r0
       andi r0,1
       ori  r0,>0500+(sprat1/>80)
       bl   @vwtr
       inv  @sprite_table_flag
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// set_sprite_table

*********************************************************************************
*
* Upload sprite attributes
*
upload_sprites:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Set destination address
       mov  @sprite_table_flag,r0
       andi r0,1
       sla  r0,7
       ai   r0,sprat1
       bl   @vwad
*      Init loop
       li   r15,vdpwd
       clr  r4                         ; Priority
       mov  @sprite_table_flag,r0
       jne  upload_sprites_1
       li   r6,hw_sprites              ; Start
       li   r5,hw_sprite_struct_size   ; Increment
       jmp  upload_sprites_2
upload_sprites_1:
       li   r5,hw_sprite_struct_size
       mpy  @max_hw_sprite,r5
       ai   r6,hw_sprites
       li   r5,-hw_sprite_struct_size
*      Loop
upload_sprites_2:
       mov  @max_hw_sprite,r2
       inc  r2
       mov  r6,r3                      ; Start address
upload_sprites_3:
       c    r4,@hw_sprite_priority(r3) ; Check priority
       jne  upload_sprites_4
       mov  *r3,r1                     ; Get parent sprite
       jeq  upload_sprites_4
       mov  @sprite_x(r1),r7
       a    @hw_sprite_dx(r3),r7
       ci   r7,(x_min-16)*256          ; Check for x out of bound
       jl   upload_sprites_4
       mov  @sprite_y(r1),r0
       a    @hw_sprite_dy(r3),r0
       movb r0,*r15
       movb r7,*r15
       movb @hw_sprite_pattern(r3),*r15
       movb @hw_sprite_color(r3),*r15
upload_sprites_4:
       a    r5,r3
       dec  r2
       jne  upload_sprites_3
       inc  r4
       ci   r4,3
       jne  upload_sprites_2
*      End marker
       li   r0,>d000
       movb r0,*r15
*      Return
upload_sprites_5:
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// upload_sprites

*********************************************************************************
*
* User input
*
user_input:
       mov  r11,*r10+                  ; Push return address onto the stack
       abs  @user_input_enabled        ; Check if user input is enabled
       jeq  user_input_2
*      Reset velocity
       li   r1,sprite_player
       clr  @sprite_vx(r1)
       clr  @sprite_vy(r1)
*      Select input device
       mov  @user_input_device,r0
       jne  user_input_1
       bl   @keyboard_input
       jmp  user_input_2
user_input_1:
       bl   @joystick_input
user_input_2:
*      Check quit
       bl   @check_quit
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// user_input

*********************************************************************************
*
* Keyboard input
*
keyboard_input:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Fire
       li   r0,KEY_SP
       bl   @check_key
       jeq  keyboard_input_1
       mov  @player_fire,r0            ; Test if ready
       jgt  keyboard_input_2
       seto @player_fire               ; -1=Pressed and ready
       jmp  keyboard_input_3
keyboard_input_1:
       clr  @player_fire               ; 0=Released
       mov  @bomb_count_down,r0        ; Check for bomb in progress
       jlt  keyboard_input_3
       clr  @bomb_count_down
       jmp  keyboard_input_3
keyboard_input_2:
       mov  @bomb_count_down,r0        ; Check for bomb in progress
       jlt  keyboard_input_3
       inc  @bomb_count_down
keyboard_input_3:
*      Left
       li   r0,KEY_S
       bl   @check_key
       jeq  keyboard_input_4
       li   r0,-player_speed
       mov  r0,@sprite_vx(r1)
       jmp  keyboard_input_5
keyboard_input_4:
*      Right
       li   r0,KEY_D
       bl   @check_key
       jeq  keyboard_input_5
       li   r0,player_speed
       mov  r0,@sprite_vx(r1)
keyboard_input_5:
*      Down
       li   r0,KEY_X
       bl   @check_key
       jeq  keyboard_input_6
       li   r0,player_speed
       mov  r0,@sprite_vy(r1)
       jmp  keyboard_input_7
keyboard_input_6:
*      Up
       li   r0,KEY_E
       bl   @check_key
       jeq  keyboard_input_7
       li   r0,-player_speed
       mov  r0,@sprite_vy(r1)
*      Return
keyboard_input_7:
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// keyboard_input

*********************************************************************************
*
* Joystick input
*
joystick_input:
*      Read joystick #1 using CRU
       li   r12,>0024                  ; CRU address of the column decoder
       li   r0,>0600                   ; Column 6, i.e joystick #1
       ldcr r0,3                       ; Select it
       li   r12,>0006                  ; Base CRU address for joystick 1
*      Fire
       tb   0
       jeq  joystick_input_1
       mov  @player_fire,r0            ; Test if ready
       jgt  joystick_input_2
       seto @player_fire               ; -1=Pressed and ready
       jmp  joystick_input_3
joystick_input_1:
       clr  @player_fire               ; 0=Released
       mov  @bomb_count_down,r0        ; Check for bomb in progress
       jlt  joystick_input_3
       clr  @bomb_count_down
       jmp  joystick_input_3
joystick_input_2:
       mov  @bomb_count_down,r0        ; Check for bomb in progress
       jlt  joystick_input_3
       inc  @bomb_count_down
joystick_input_3:
*      Left
       tb   1
       jeq  joystick_input_4
       li   r0,-player_speed
       mov  r0,@sprite_vx(r1)
       jmp  joystick_input_5
joystick_input_4:
*      Right
       tb   2
       jeq  joystick_input_5
       li   r0,player_speed
       mov  r0,@sprite_vx(r1)
joystick_input_5:
*      Down
       tb   3
       jeq  joystick_input_6
       li   r0,player_speed
       mov  r0,@sprite_vy(r1)
       jmp  joystick_input_7
joystick_input_6:
*      Up
       tb   4
       jeq  joystick_input_7
       li   r0,-player_speed
       mov  r0,@sprite_vy(r1)
joystick_input_7:
       b    *r11
*// joystick_input

*********************************************************************************
*
* Fire weapons
*
fire:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @player_fire,r0
       jgt  fire_1
       jeq  fire_1
*      Check power ups
       mov  @power_ups,r0
       jne  fire_2
       bl   @add_bullet_sprite
       jmp  fire_4
fire_2:
       ci   r0,power_up_double_shot
       jne  fire_3
*      Double
       bl   @add_double_bullet_sprite
       jmp  fire_4
fire_3:
*      Triple
       bl   @add_triple_bullet_sprite
fire_4:
       li   r1,shot_1
       bl   @init_sfx
       neg  @player_fire
*      Return
fire_1:
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// fire

*********************************************************************************
*
* Fire smart bomb
*
smart_bomb:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @bomb_count_down,r0
       jlt  smart_bomb_5
       ci   r0,32
       jlt  smart_bomb_6
*      Initiate bomb
       clr  @bomb_count_down
       mov  @smart_bombs,r0
       jeq  smart_bomb_6
       dec  @smart_bombs
       bl   @display_smart_bombs
*      Destroy enemies
       mov  @max_sprite,r8
       inc  r8
       li   r9,sprites
smart_bomb_1:
       mov  *r9,r1                     ; Get sprite definition
       jeq  smart_bomb_4
       mov  @sprite_def_type(r1),r1    ; Get sprite type
       ci   r1,sprite_type_enemy_plane
       jeq  smart_bomb_2
       ci   r1,sprite_type_turret
       jeq  smart_bomb_2
       ci   r1,sprite_type_tank
       jeq  smart_bomb_2
       jmp  smart_bomb_4
smart_bomb_2:
       li   r0,sprite_def_bullet
       bl   @alloc_sprite
       mov  r9,r3
       mov  r1,r5
       jeq  smart_bomb_3
       bl   @explode_bullet
smart_bomb_3:
       mov  r9,r1
       bl   @dealloc_sprite
smart_bomb_4:
       ai   r9,sprite_struct_size
       dec  r8
       jne  smart_bomb_1
*      Blank screen
       li   r0,>01a2
       bl   @vwtr
*      Bomb in progress
smart_bomb_5:
       mov  @bomb_count_down,r1
       neg  r1
       li   r0,>0007
       movb @bomb_colors(r1),r0
       swpb r0
       bl   @vwtr
       dec  @bomb_count_down
       mov  @bomb_count_down,r0
       ci   r0,-8
       jgt  smart_bomb_6
*      Done
       clr  @bomb_count_down
*      Show screen
       li   r0,>01e2
       bl   @vwtr
*      Return
smart_bomb_6:
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
bomb_colors:
       byte >0a,>0b,>0f,>0f,>0f,>0b,>0a,>01
*// smart_bomb

*********************************************************************
*
* Add score
*
* r0 contains the score to add
*
* Modifies r0-r1,r4
*
add_score:
       mov  r11,*r10+                  ; Push return address onto the stack
       a    r0,@score_lsw
       jnc  add_score_1
       inc  @score_msw
add_score_1:
       bl   @display_score
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// add_score

*********************************************************************
*
* Display score
*
* Modifies r0-r1,r4
*
display_score:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  r2,*r10+
       mov  r3,*r10+
       mov  @score_msw,r0
       mov  @score_lsw,r1
       li   r2,6                       ; Counter
       li   r3,10                      ; Divisor
       li   r4,numbuf+5                ; Start backwards
*      Digit loop
display_score_1:
       div  r3,r0                      ; Divide to get digit as remainder in r1
       ai   r1,chzero                  ; Add char code for zero
       swpb r1                         ; Swap to high byte
       movb r1,*r4                     ; Store digit in buffer
       dec  r4                         ; Next digit in buffer (working backwards)
       mov  r0,r1
       clr  r0
       dec  r2                         ; Count down
       jne  display_score_1            ; Digit loop
*      Display to VDP
       li   r0,10*32+panel_left+((panel_width-6)/2)
       li   r1,numbuf
       li   r2,6
       bl   @display_text
*      Return
       dect r10
       mov  *r10,r3
       dect r10
       mov  *r10,r2
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
numbuf byte chzero, chzero, chzero, chzero, chzero, chzero
*// display_score

*********************************************************************
*
* Display level
*
display_level:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @level,r0
       ai   r0,chzero+1
       mov  r0,@lvlbuf
*      Display to VDP
       li   r0,14*32+panel_left+((panel_width-2)/2)+1
       li   r1,lvlbuf+1
       li   r2,1
       bl   @display_text
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
lvlbuf byte chzero, chzero
*// display_level

*********************************************************************
*
* Display lives
*
display_lives:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  r2,*r10+
       mov  r3,*r10+
       mov  @lives,r6
       jgt  display_lives_0
       clr  r6
       jmp  display_lives_1
display_lives_0:
       ci   r6,4
       jle  display_lives_1
       li   r6,4
display_lives_1:
       sla  r6,4
       ai   r6,lives0
       li   r0,17*32+panel_left+((panel_width-8)/2)
       mov  r6,r1
       li   r2,8
       bl   @display_text
       ai   r6,8
       li   r0,18*32+panel_left+((panel_width-8)/2)
       mov  r6,r1
       li   r2,8
       bl   @display_text
*      Return
       dect r10
       mov  *r10,r3
       dect r10
       mov  *r10,r2
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
lives0:
       byte >ff,>ff,>ff,>ff,>ff,>ff,>ff,>ff
       byte >ff,>ff,>ff,>ff,>ff,>ff,>ff,>ff
lives1:
       byte >70,>72,>ff,>ff,>ff,>ff,>ff,>ff
       byte >78,>7a,>ff,>ff,>ff,>ff,>ff,>ff
lives2:
       byte >70,>72,>70,>72,>ff,>ff,>ff,>ff
       byte >78,>7a,>78,>7a,>ff,>ff,>ff,>ff
lives3:
       byte >70,>72,>70,>72,>70,>72,>ff,>ff
       byte >78,>7a,>78,>7a,>78,>7a,>ff,>ff
lives4:
       byte >70,>72,>70,>72,>70,>72,>70,>72
       byte >78,>7a,>78,>7a,>78,>7a,>78,>7a
*// display_lives

*********************************************************************
*
* Display smart bombs
*
display_smart_bombs:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  r2,*r10+
       mov  r3,*r10+
       mov  @smart_bombs,r6
       jgt  display_smart_bombs_1
       clr  r6
       jmp  display_smart_bombs_2
display_smart_bombs_1:
       ci   r6,4
       jle  display_smart_bombs_2
       li   r6,4
display_smart_bombs_2:
       sla  r6,4
       ai   r6,bombs0
       li   r0,20*32+panel_left+((panel_width-8)/2)
       mov  r6,r1
       li   r2,8
       bl   @display_text
       ai   r6,8
       li   r0,21*32+panel_left+((panel_width-8)/2)
       mov  r6,r1
       li   r2,8
       bl   @display_text
*      Return
       dect r10
       mov  *r10,r3
       dect r10
       mov  *r10,r2
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
bombs0:
       byte >ff,>ff,>ff,>ff,>ff,>ff,>ff,>ff
       byte >ff,>ff,>ff,>ff,>ff,>ff,>ff,>ff
bombs1:
       byte >74,>76,>ff,>ff,>ff,>ff,>ff,>ff
       byte >7c,>7e,>ff,>ff,>ff,>ff,>ff,>ff
bombs2:
       byte >74,>76,>74,>76,>ff,>ff,>ff,>ff
       byte >7c,>7e,>7c,>7e,>ff,>ff,>ff,>ff
bombs3:
       byte >74,>76,>74,>76,>74,>76,>ff,>ff
       byte >7c,>7e,>7c,>7e,>7c,>7e,>ff,>ff
bombs4:
       byte >74,>76,>74,>76,>74,>76,>74,>76
       byte >7c,>7e,>7c,>7e,>7c,>7e,>7c,>7e
*// display_smart_bombs

*********************************************************************************
*
* Update character list
*
* Modifies r0-r3
*
update_char_list:
       mov  @cart_diff_bank,r0         ; Select ROM bank
       seto *r0
       mov  @scroll_y,r0
       andi r0,7
       jne  update_char_list_5
       mov  @diff_ptr,r0
       clr  r1
*      Additions
       movb *r0+,r2                    ; Additions counter
       jeq  update_char_list_2
       srl  r2,8
update_char_list_1:
       movb *r0+,r1                    ; Char number
       srl  r1,7                       ; Char offset
       movb *r0+,r3                    ; Global char number MSB
       movb *r0+,@r3lb                 ; Global char number LSB
       sla  r3,3                       ; 8 bytes per pattern/color
       ai   r3,cart_base               ; Add cartridge base address
       mov  r3,@char_list(r1)          ; Store in character list
       dec  r2
       jne  update_char_list_1
*      Deletions
update_char_list_2:
       movb *r0+,r2                    ; Deletions counter
       jeq  update_char_list_4
       srl  r2,8
update_char_list_3:
       movb *r0+,r1                    ; Char number
       srl  r1,7                       ; Char offset
       seto @char_list(r1)             ; Mark as not used in character list
       dec  r2
       jne  update_char_list_3
update_char_list_4:
       mov  r0,@diff_ptr
update_char_list_5:
*      Return
       b    *r11
*// update_char_list

*********************************************************************************
*
* Update characters
*
update_characters:
       mov  r11,*r10+                  ; Push return address onto the stack
       bl   @interrupt_check
       mov  @scroll_y,r3               ; Read scroll offset into register
*       Calculate VDP RAM destination address
       coc  @one,r3                    ; Check which character set to update
       jeq  update_low_chars
       li   r6,>400                    ; Update high character set (128-255)
       jmp  update_characters_1
update_low_chars:
       clr  r6                         ; Update low character set (128-255)
update_characters_1:
*       Select source ROM bank
       mov  r3,r5                      ; Start with scroll offset
       a    @direction,r5              ; Add direction
       andi r5,>0007                   ; Mod 8
       sla  r5,1                       ; Bank select offset
       a    @cart_pattern_bank,r5      ; Add base pattern bank select
       seto *r5
*      Upload characters
       li   r15,vdpwd
       li   r14,vdpwa
       li   r13,8
*      Patterns
       clr  r1
       li   r0,ptrntb
       a    r6,r0
       bl   @vwad
       bl   @upload_character_table_pad
       bl   @interrupt_check
       li   r0,ptrntb+>800
       a    r6,r0
       bl   @vwad
       seto *r5
       bl   @upload_character_table_pad
       bl   @interrupt_check
       li   r0,ptrntb+>1000
       a    r6,r0
       bl   @vwad
       seto *r5
       bl   @upload_character_table_pad
       bl   @interrupt_check
*      Colors
       li   r1,>1000
       li   r0,colrtb
       a    r6,r0
       bl   @vwad
       seto *r5
       bl   @upload_character_table_pad
       bl   @interrupt_check
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// update_characters

*********************************************************************************
*
* Upload character table
*
* VDP write address must have been set up in advance.
*
* r1:  Source offset
* r13: Offset between characters (8)
* r14: vdpwa
* r15: vdpwd
*
upload_character_table:
       mov  @max_chars,r2              ; Char counter
       li   r3,char_list
upload_character_table_1:
       mov  *r3+,r4                    ; Get pattern address
       jlt  upload_character_table_2   ; If negative, character is not used
       a    r1,r4                      ; Add source offset
       movb *r4+,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       movb *r4+,*r15
       a    r13,r0
       dec  r2
       jne  upload_character_table_1
       b    *r11
upload_character_table_2:
       a    r13,r0
       movb @r0lb,*r14                 ; Send low byte of VDP RAM write address
       movb r0,*r14                    ; Send high byte of VDP RAM write address
       dec  r2
       jne  upload_character_table_1
       b    *r11
upload_character_table_end
*// upload_character_table

*********************************************************************
*
* Update name table off-screen buffer
*
update_name_table:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @scroll_y,r3               ; Get scroll frame (0-15)
       andi r3,>000f
*       Calculate row offset to the 1/4 of the buffer to update
       mov  r3,r0                      ; Start with frame number
       andi r0,>0006                   ; Transform to sequence: 0,0,2,2,4,4,6,6...
       mov  r0,r2                      ; Copy to R2
       sla  r0,1                       ; Multiply by 2
       a    r0,r2                      ; Add to R2 to multiply by 6 and get row offset: 0,0,6,6,12,12,18,18...
       mov  r2,r0                      ; Copy back into R0 for later
*       Calculate map source address in R1
       mov  @scroll_y,r1               ; Get scroll offset in pixels
       sra  r1,3                       ; Divide by 8 to get row offset
       a    r2,r1                      ; Add the row offset we calculated before
       li   r2,map_width
       mpy  r2,r1                      ; Multiply by map width to get character offset
       li   r1,cart_base               ; Get the map base address
       a    r2,r1                      ; Add the character offset
*       Calculate buffer destination address in R0
       sla  r0,5                       ; Convert row offset to character offset
       ai   r0,map_left
*       Decide which buffer to update
       coc  @eight,r3                  ; Bit weight >08 determines the group
       jne  update_name_table_2        ; If not set we update buffer 2 or 3
       coc  @one,r3                    ; Bit weight >01 determines the buffer
       jeq  update_name_table_1
       ai   r0,namet1                  ; Add base address to character offset
       mov  @cart_map_bank,r5
       jmp  update_name_table_4
update_name_table_1:
       ai   r0,namet2                  ; Add base address to character offset
       mov  @cart_map_high_bank,r5
       jmp  update_name_table_4
update_name_table_2:
       coc  @one,r3                    ; Bit weight >01 determines the buffer
       jeq  update_name_table_3
       ai   r0,namet3                  ; Add base address to character offset
       mov  @cart_map_bank,r5
       jmp  update_name_table_4
update_name_table_3:
       ai   r0,namet4                  ; Add base address to character offset
       mov  @cart_map_high_bank,r5
update_name_table_4:
       seto *r5                        ; Select map cartridge bank
*       Copy to VDP RAM buffer
       li   r15,vdpwd
       li   r2,6
update_name_table_5:
       bl   @vwad
       li   r3,win_width/6
update_name_table_6:
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       movb *r1+,*r15
       dec  r3
       jne  update_name_table_6
       bl   @interrupt_check
       seto *r5
       ai   r0,scr_width               ; Next VDP row
       dec  r2
       jne  update_name_table_5
*       Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// update_name_table

*********************************************************************************
*
* Simulate scrolling the map from the beginning to the position in @scrly_current
* This is required in order to back-track on the map after dying.
*
scroll_to_position:
       mov  r11, *r10+                  ; Push return address onto the stack
*      Screen off
       li   r0,>01a2
       bl   @vwtr
*      Init scroll
       bl   @init_scroll
scroll_to_position_1:
       mov  @diff_ptr,r4
       bl   @update_char_list          ; Determine which characters to update
       c    @scroll_y,@scroll_y_current
       jle  scroll_to_position_2
       dec  @scroll_y
       jmp  scroll_to_position_1
scroll_to_position_2:
       mov  @scroll_y,@scroll_y_last
       mov  r4,@diff_ptr
       bl   @update_characters
       dec  @scroll_y
       clr  @direction
       bl   @update_characters
       seto @direction
       inc  @scroll_y
       bl   @draw_initial_screen
*      Set sprite position list pointer
*      to the entry at or just before the current scroll y
       mov  @sprite_pos_ptr,r1
scroll_to_position_3:
       mov  *r1,r0
       jlt  scroll_to_position_6
       c    r0,@scroll_y_current
       jeq  scroll_to_position_5
       jl   scroll_to_position_4
       ai   r1,sprite_pos_struct_size
       jmp  scroll_to_position_3
scroll_to_position_4:
       c    @sprite_pos_ptr,r1
       jeq  scroll_to_position_6
       ai   r1,-sprite_pos_struct_size ; We have come too far
scroll_to_position_5:
       mov  r1,@sprite_pos_ptr
*      Reset sprites
scroll_to_position_6:
       bl   @init_sprites
*      Screen on
       li   r0,>01e2
       bl   @vwtr
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// scroll_to_position

*********************************************************************************
*
* Draw initial screen
*
draw_initial_screen:
       mov  r11, *r10+                 ; Push return address onto the stack
       li   r15,vdpwd
*      Source address
       mov  @scroll_y,r1
       srl  r1,3
       li   r0,map_width
       mpy  r1,r0                      ; (y / 8) * map_width
       ai   r1,cart_base
       mov  r1,r4
*      Update all names tables
       li   r6,namet1+map_left
       li   r7,4
*      Name table
draw_screen_0:
       mov  r6,r0
       mov  r4,r1
       li   r2,win_height
       coc  @one,r7
       jeq  draw_screen_3
       mov  @cart_map_bank,r5
       jmp  draw_screen_4
draw_screen_3:
       mov  @cart_map_high_bank,r5
draw_screen_4:
       seto *r5
draw_screen_1:
       bl   @vwad
       li   r3,win_width
draw_screen_2:
       movb *r1+,*r15
       dec  r3
       jne  draw_screen_2
       ai   r0,scr_width
       dec  r2
       jne  draw_screen_1
*      Next name table
       ai   r6,>400
       dec  r7
       jne  draw_screen_0
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// draw_initial_screen

*********************************************************************************
*
* One time initializations
*
init:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Init variables
       li   r0,1
       mov  r0,@one
       li   r0,8
       mov  r0,@eight
*      High scores
       li   r0,high_scores
       li   r1,high_scores+2
       li   r2,(n_high_scores*4)-2
       clr  *r0
       bl   @copy_memory
*      Copy code to pad
       li   r0,upload_character_table
       li   r1,upload_character_table_pad
       li   r2,upload_character_table_end-upload_character_table
       bl   @copy_memory
*      User input disabled for demo
       clr  @user_input_enabled
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// init

*********************************************************************************
*
* Initialize game
*
init_game:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Init variables
       li   r0,start_level
       mov  r0,@level
       clr  @score_lsw
       clr  @score_msw
       li   r0,start_lives
       mov  r0,@lives
       clr  @status
       li   r0,start_bombs
       mov  r0,@smart_bombs
       li   r0,power_up_none
       mov  r0,@power_ups
       clr  @sprite_table_flag
       clr  @bomb_count_down
*      Init sprites
       bl   @init_sprites
*      Draw panel
       li   r0,panel_left*256
       li   r1,MD0
       li   r2,panel_width
       li   r3,24
       li   r4,0
       bl   @draw_box
*      Init display
       bl   @display_lives
       bl   @display_smart_bombs
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// init_game

*********************************************************************************
*
* Initialize sprites
*
init_sprites:
       mov  r11,*r10+                  ; Push return address onto the stack
       li   r0,sprites
       li   r2,n_sprites*sprite_struct_size
       bl   @clear_memory
       seto @max_sprite
       li   r0,hw_sprites
       li   r2,n_hw_sprites*hw_sprite_struct_size
       bl   @clear_memory
       seto @max_hw_sprite
*      Init player sprite
       li   r0,sprite_def_player
       bl   @alloc_sprite
       li   r0,(x_min+((x_max-x_min)/2)-8)*256
       movb r0,@sprite_x(r1)
       li   r0,>9f00
       movb r0,@sprite_y(r1)
       clr  @sprite_vx(r1)
       clr  @sprite_vy(r1)
       clr  @sprite_count(r1)
*      Backdrop
       mov  @sprite_hw_1(r1),r2
       clr  @hw_sprite_priority(r2)
       li   r0,>0100
       mov  @sprite_hw_2(r1),r2
       mov  r0,@hw_sprite_color(r2)
       mov  @one,@hw_sprite_priority(r2)
*      Shadow
       mov  @sprite_hw_3(r1),r2
       mov  r0,@hw_sprite_color(r2)
       li   r0,>1000
       mov  r0,@hw_sprite_dx(r2)
       mov  r0,@hw_sprite_dy(r2)
*      Sprite attributes
       li   r0,sprat1
       li   r1,>d000
       bl   @vsbw
       li   r0,sprat2
       li   r1,>d000
       bl   @vsbw
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// init_sprites

*********************************************************************************
*
* Initialize level
*
init_level:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Screen off
       li   r0,>01a2
       bl   @vwtr
*      Cartridge addresses
       li   r0,24
       mpy  @level,r0                  ; Level * 24 (12 banks per level)
       ai   r1,levels_base_bank        ; First 4 banks are for code, 2 for title screen
       mov  r1,@cart_pattern_bank
       ai   r1,16
       mov  r1,@cart_map_bank
       inct r1
       mov  r1,@cart_map_high_bank
       inct r1
       mov  r1,@cart_diff_bank
       inct r1
       mov  r1,@cart_music_bank
*      Initalize scroll
       bl   @init_scroll
       mov  @scroll_y,@scroll_y_current
       mov  @scroll_y,@scroll_y_last
*      Draw initial screen
       mov  @diff_ptr,r4
       bl   @update_char_list
       mov  r4,@diff_ptr
       bl   @update_characters         ; Needed when changing level
       dec  @scroll_y
       clr  @direction
       bl   @update_characters
       seto @direction
       inc  @scroll_y
       bl   @draw_initial_screen
*      Display score and level
       bl   @display_score
       bl   @display_level
*      Music
       li   r1,cart_music_base
       bl   @init_music
*      Enable user input
       seto @user_input_enabled
*      Screen on
       li   r0,>01e2
       bl   @vwtr
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// init_level

*********************************************************************
*
* Initalize scroll
*
init_scroll:
*      Init variables
       mov  @level,r1
       sla  r1,1
       mov  @map_heights(r1),@map_height
       mov  @map_height,r0
       ai   r0,-win_height
       sla  r0,3
       mov  r0,@scroll_y
       mov  r0,@scroll_y_max
       ai   r0,-64
       mov  r0,@take_off_end
       li   r0,64
       mov  r0,@landing_start
       mov  @sprite_pos_lists(r1),@sprite_pos_ptr
*      Init diff list
       mov  @cart_diff_bank,r0
       seto *r0
       li   r0,cart_base
       clr  @max_chars
       movb *r0+,@max_chars+1
       mov  r0,@diff_ptr
*      Reset character list
       li   r0,char_list
       li   r2,128
init_scroll_1:
       seto *r0+
       dec  r2
       jne  init_scroll_1
*      Reset waves
       li   r1,waves
init_scroll_2:
       mov  @wave_total(r1),@wave_left(r1)
       jlt  init_scroll_3
       ai   r1,wave_size
       jmp  init_scroll_2
init_scroll_3:
       b    *r11
*// init_scroll

*********************************************************************************
*
* Display "get ready" and wait
*
display_get_ready:
       mov  r11,*r10+                  ; Push return address onto the stack
       li   r0,7*32+19
       li   r1,txt_get_ready
       li   r2,9
       bl   @display_text
       li   r2,60
       bl   @wait
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// display_get_ready

*********************************************************************************
*
* Actions when died
*
died:
       mov  r11,*r10+                  ; Push return address onto the stack
       clr  @power_ups
       clr  @status
       li   r0,60
       mov  r0,@sprite_player+sprite_count
       mov  @scroll_y_current,r0
       ai   r0,>01ff
       andi r0,>fe00
       c    r0,@scroll_y_max
       jle  !
       mov  @scroll_y_max,r0
!      mov  r0,@scroll_y_current
       bl   @scroll_to_position
       seto @user_input_enabled
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// died

*********************************************************************************
*
* Actions when game is over
*
game_over:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Register high score
       bl   @update_high_scores
*      Display "game over"
       li   r0,7*32+19
       li   r1,txt_game_over
       li   r2,9
       bl   @display_text
*      Music
       li   r0,landing_music_bank
       mov  r0,@cart_music_bank
       li   r1,cart_music_base
       inc  @tune_no
       bl   @init_music
       dec  @tune_no
*      Wait
       li   r2,300
       bl   @wait
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// game_over

*********************************************************************
*
* Update high score table with new score
*
update_high_scores:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Check new score against existng high scores
       li   r1,high_scores             ; Existing high scores
       li   r2,n_high_scores           ; Number of high scores to compare against
update_high_scores_1:
       c    @score_msw,*r1
       jgt  update_high_scores_3
       jlt  update_high_scores_2
       c    @score_lsw,@2(r1)
       jgt  update_high_scores_3
update_high_scores_2:
       ai   r1,4                       ; Next high score
       dec  r2
       jne  update_high_scores_1
       jmp  update_high_scores_6       ; Not a new high score - return
update_high_scores_3:
*      New high score found, r1 contains insertion point
       li   r3,high_scores+((n_high_scores-1)*4)    ; Last high score entry
update_high_scores_4:
       c    r3,r1                      ; Compare with insertion point
       jeq  update_high_scores_5
*      Move previous entry to this entry
       mov  @-4(r3),*r3+
       mov  @-4(r3),*r3+
       ai   r3,-8
       jmp  update_high_scores_4
*      Copy new score into table
update_high_scores_5:
       mov  @score_msw,*r1+
       mov  @score_lsw,*r1+
*      Return
update_high_scores_6:
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// update_high_scores

*********************************************************************
*
* Clear memory
*
* r0: Start address
* r2: Length
*
clear_memory:
       clr  *r0+
       dect r2
       jne  clear_memory
       b    *r11
*// clear_memory

*********************************************************************
*
* Copy memory
*
* r0: Source address
* r1: Destination address
* r2: Length
*
copy_memory:
       mov  *r0+,*r1+
       dect r2
       jne  copy_memory
       b    *r11
*// copy_memory

*********************************************************************************
*
* Set graphics mode
*
gmode:
       mov  r11,*r10+                  ; Push return address onto the stack
       clr  r0
       li   r1,vregs
       li   r2,8
gmode_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  gmode_1
*      Patterns
       li   r0,ptrntb
       clr  r1
       li   r2,>800
       bl   @vdpwr
       li   r0,8*112+ptrntb
       li   r1,PAT112T
       li   r2,16*8
       bl   @vdpcp
       li   r0,8*112+ptrntb+>800
       li   r1,PAT112M
       li   r2,16*8
       bl   @vdpcp
       li   r0,8*112+ptrntb+>1000
       li   r1,PAT112B
       li   r2,16*8
       bl   @vdpcp
       li   r0,8*240+ptrntb
       li   r1,PAT240T
       li   r2,16*8
       bl   @vdpcp
       li   r0,8*240+ptrntb+>800
       li   r1,PAT240M
       li   r2,16*8
       bl   @vdpcp
       li   r0,8*240+ptrntb+>1000
       li   r1,PAT240B
       li   r2,16*8
       bl   @vdpcp
*      Colors
       li   r0,colrtb
       clr  r1
       li   r2,>800
       bl   @vdpwr
       li   r0,8*112+colrtb
       li   r1,COL112
       li   r2,16*8
       bl   @vdpcp
       li   r0,8*240+colrtb
       li   r1,COL240
       li   r2,16*8
       bl   @vdpcp
*      Name tables
       li   r0,namet1
       li   r1,>ff00
       li   r2,>1000
       bl   @vdpwr
*      Sprite patterns
       li   r0,sprptb
       li   r1,spr0
       li   r2,64*32
       bl   @vdpcp
       clr  @boat_patterns_uploaded
       clr  @big_plane_patterns_uploaded
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*      VDP registers
vregs:
       byte >02                        ; Graphics II mode
       byte >a2                        ; 16K, display off, interrupt enabled
       byte namet1/>400                ; Name table
       byte >9f                        ; Color table
       byte ptrntb/>800+>03            ; Pattern table
       byte sprat1/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >01                        ; Backdrop color
*// gmode

*********************************************************************************
*
* Title screen, full bitmap mode
*
title_screen:
       mov  r11,*r10+                  ; Push return address onto the stack
       clr  r0
       li   r1,vregs2
       li   r2,8
title_screen_1:
       movb *r1+,@r0lb
       bl   @vwtr                      ; Set register
       ai   r0,>0100
       dec  r2
       jne  title_screen_1
*      Name table
       li   r0,namet5
       bl   @vwad
       clr  r1
       li   r2,>300
title_screen_2:
       movb r1,@vdpwd
       ai   r1,>0100
       dec  r2
       jne  title_screen_2
*      Sprite attributes
       li   r0,sprat3
       li   r1,>d000
       bl   @vsbw
*      Init music
       li   r0,title_music_bank
       mov  r0,@cart_music_bank
       li   r1,cart_music_base
       bl   @init_music
title_screen_3:
*      Display title screen
       bl   @display_title_screen
       li   r3,360
       clr  r4
       bl   @wait_key_timeout
       mov  r3,r3
       jne  title_screen_4
*      Display high scores
       bl   @display_high_scores
       li   r3,240
       li   r4,display_copper_bar
       bl   @wait_key_timeout
       mov  r3,r3
       jne  title_screen_4
*      Loop
       jmp  title_screen_3
title_screen_4:
*      Stop music
       clr  @music
       bl   @mute_sound
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*      VDP registers
vregs2:
       byte >02                        ; Graphics II mode
       byte >a2                        ; 16K, display off, interrupt enabled
       byte namet5/>400                ; Name table
       byte >ff                        ; Color table
       byte ptrntb/>800+>03            ; Pattern table
       byte sprat3/>80                 ; Sprite attribute table
       byte sprptb/>800                ; Sprite pattern table
       byte >01                        ; Backdrop color
*// title_screen

*********************************************************************************
*
* Display title screen, full bitmap mode
*
display_title_screen:
       mov  r11,*r10+                  ; Push return address onto the stack
       bl   @play_sound_check
*      Screen off
       li   r0,>01a2
       bl   @vwtr
*      Patterns
       li   r0,ptrntb
       bl   @vwad
       li   r3,8
       li   r4,>6800
       li   r5,vdpwd
display_title_screen_1:
       seto @title_bank
       li   r2,>1800/(8*4)
display_title_screen_2:
       movb *r4+,*r5
       movb *r4+,*r5
       movb *r4+,*r5
       movb *r4+,*r5
       dec  r2
       jne  display_title_screen_2
       bl   @play_sound_check
       dec  r3
       jne  display_title_screen_1
*      Colors
       li   r0,colrtb
       bl   @vwad
       li   r3,8
       li   r4,>6800
       li   r5,vdpwd
display_title_screen_4:
       seto @title_bank+2
       li   r2,>1800/(8*4)
display_title_screen_5:
       movb *r4+,*r5
       movb *r4+,*r5
       movb *r4+,*r5
       movb *r4+,*r5
       dec  r2
       jne  display_title_screen_5
       bl   @play_sound_check
       dec  r3
       jne  display_title_screen_4
*      Screen on
       li   r0,>01e2
       bl   @vwtr
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// display_title_screen

*********************************************************************************
*
* Display high scores, full bitmap mode
*
display_high_scores:
       mov  r11,*r10+                  ; Push return address onto the stack
*      Screen off
       li   r0,>01a2
       bl   @vwtr
*      Patterns
       li   r0,ptrntb
       bl   @vwad
       li   r3,8
       li   r5,vdpwd
display_high_scores_5:
       li   r2,>1800/(8*4)
display_high_scores_6:
       clr  *r5
       clr  *r5
       clr  *r5
       clr  *r5
       dec  r2
       jne  display_high_scores_6
       bl   @play_sound_check
       dec  r3
       jne  display_high_scores_5
*      Colors
       li   r0,colrtb
       bl   @vwad
       li   r3,8
       li   r5,vdpwd
       li   r6,>f100
display_high_scores_7:
       li   r2,>1800/(8*4)
display_high_scores_8:
       movb  r6,*r5
       movb  r6,*r5
       movb  r6,*r5
       movb  r6,*r5
       dec  r2
       jne  display_high_scores_8
       bl   @play_sound_check
       dec  r3
       jne  display_high_scores_7
*      Display "HIGH SCORES"
       li   r0,11*8+256+ptrntb
       li   r1,PAT240B
       li   r2,4*8
       bl   @vdpcp
       li   r0,16*8+256+ptrntb
       li   r1,PAT244B
       li   r2,5*8
       bl   @vdpcp
*      Display high scores
       li   r0,13*8+768+ptrntb
       li   r1,high_scores
       li   r2,n_high_scores
display_high_scores_1:
       mov  *r1+,r3                    ; MSW
       mov  *r1+,r4                    ; LSW
       li   r5,10                      ; Divisor
       li   r6,6                       ; Digits
       li   r7,number_buffer+11
display_high_scores_2:
       div  r5,r3                      ; Divide
       mov  r4,*r7                     ; Save remainder
       mov  r3,r4
       clr  r3
       dect r7
       dec  r6
       jne  display_high_scores_2
*      Display digits
       bl   @vwad
       li   r6,6
       li   r7,number_buffer
*      Display digit
display_high_scores_3:
       mov  *r7+,r3
       sla  r3,3                       ; Multiply by 8
       ai   r3,PAT240M                 ; Add pattern base
       li   r8,8
display_high_scores_4:
       movb *r3+,@vdpwd
       dec  r8
       jne  display_high_scores_4
*      Next digit
       dec  r6
       jne  display_high_scores_3
*      Next high score
       bl   @play_sound_check
       ai   r0,>200
       dec  r2
       jne  display_high_scores_1
*      Screen on
       li   r0,>01e2
       bl   @vwtr
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
number_buffer:
       data 0,0,0,0,0,0
*// display_high_scores

*********************************************************************************
*
* Display copper bar (high score screen)
*
display_copper_bar:
       mov  r11,*r10+                  ; Push return address onto the stack
       lwpi wrksp2
       mov  @frame_count,r3            ; Line
       ci   r3,176
       jle  display_copper_bar_0
       li   r3,176
display_copper_bar_0:
       li   r4,11                      ; Column
*      Screen address
       mov  r3,r5
       andi r5,>00f8
       sla  r5,5
       mov  r5,r0                      ; Rows
       mov  r3,r5
       andi r5,>0007
       a    r5,r0                      ; Lines
       mov  r4,r5
       sla  r5,3
       a    r5,r0                      ; Columns
       ai   r0,colrtb                  ; Base
       mov  r0,r6
*      Column loop
display_copper_bar_1:
       bl   @vwad
       li   r1,copper_bar
       li   r2,16
       mov  r3,r5
*      Row loop
display_copper_bar_2:
       movb *r1+,@vdpwd
       inc  r5
       andi r5,>0007
       jne  display_copper_bar_3
       ai   r0,256
       andi r0,>fff8
       bl   @vwad
display_copper_bar_3:
       dec  r2
       jne  display_copper_bar_2
       ai   r6,8
       mov  r6,r0
       inc  r4
       ci   r4,21
       jlt  display_copper_bar_1
       lwpi wrksp
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
copper_bar:
       byte >F0,>E0,>B0,>B0,>A0,>A0,>30,>30
       byte >20,>20,>C0,>C0,>20,>20,>30,>e0
*// display_copper_bar

*********************************************************************************
*
* Draw box to all name tables
*
* r0: col MSB, row LSB
* r1: source
* r2: width
* r3: height
* r4: source row offset
*
draw_box:
       mov  r11,*r10+                  ; Push return address onto the stack
       li   r15,vdpwd
       mov  r0,r5
       andi r0,>00ff
       sla  r0,5
       socb r5,@r0lb
       ai   r0,namet1
       mov  r0,r6
       mov  r1,r7
       mov  r2,r8
       mov  r3,r9
       li   r12,4
draw_box_1:
       mov  r9,r3
draw_box_2:
       bl   @vwad
       mov  r8,r2
draw_box_3:
       movb *r1+,*r15
       dec  r2
       jne  draw_box_3
       ai   r0,32
       a    r4,r1
       dec  r3
       jne  draw_box_2
       ai   r6,>400
       mov  r6,r0
       mov  r7,r1
       dec  r12
       jne  draw_box_1
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// draw_box

*********************************************************************
*
* Display text to all name table buffers
*
* r0: Screen offset (characters) of upper left corner
* r1: Source address
* r2: Length
*
* Modifies R0-R5
*
display_text:
       mov  r11,*r10+                  ; Push return address onto the stack
       li   r15,vdpwd
       ai   r0,namet1
       mov  r1,r13
       mov  r2,r14
       bl   @vwad
*      1st
!      movb *r1+,*r15
       dec  r2
       jne  -!
       ai   r0,>400
       bl   @vwad
       mov  r13,r1
       mov  r14,r2
*      2nd
!      movb *r1+,*r15
       dec  r2
       jne  -!
       ai   r0,>400
       bl   @vwad
       mov  r13,r1
       mov  r14,r2
*      3rd
!      movb *r1+,*r15
       dec  r2
       jne  -!
       ai   r0,>400
       bl   @vwad
       mov  r13,r1
       mov  r14,r2
*      4th
!      movb *r1+,*r15
       dec  r2
       jne  -!
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10, r11
       b    *r11
*// display_text

*********************************************************************
*
* VDP Write To Register
*
* R0 MSB: VDP register to write to
* R0 LSB: Value to write
*
vwtr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte (value) to write to VDP register
       swpb r0
       ori  r0,>8000                   ; Set up a VDP register write operation (10)
       movb r0,@vdpwa                  ; Send high byte (address) of VDP register
       b    *r11
*// vwtr

*********************************************************************
*
* VDP Set Write Address
*
* R0: Write address in VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vwad:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       b    *r11
*// vwad

*********************************************************************
*
* VDP Single Byte Read
*
* R0   Read address in VDP RAM
* R1   MSB of R1 set to byte from VDP RAM
*
vsbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb @vdprd,r1                  ; Read byte from VDP RAM
       b    *r11
*// vsbr

*********************************************************************
*
* VDP Single Byte Write
*
* R0: Write address in VDP RAM
* R1: MSB of R1 sent to VDP RAM
*
* R0 is modified, but can be restored with: ANDI R0,>3FFF
*
vsbw:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set read/write bits 14 and 15 to write (01)
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       movb r1,@vdpwd                  ; Write byte to VDP RAM
       b    *r11
*// vsbw

***************************************************************************
*
* VDP Multiple Byte Read
*
* R0: Starting read address in VDP RAM
* R1: Starting write address in CPU RAM
* R2: Number of bytes to read from VDP RAM
*
* Modifies R0-R2
*
vmbr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
vmbr0:
       li   r0,vdprd
vmbr1:
       movb *r0,*r1+                   ; Read byte from VDP RAM
       dec  r2                         ; Byte counter
       jne  vmbr1                      ; Check if finished
       b    *r11
*// vmbr

*********************************************************************
*
* Fast CPU to VDP copy, replaces VMBW
*
* R0: Destination address
* R1: Source address
* R2: Number of bytes to copy
*
* Modifies r0-r3
*
vdpcp:
       mov  r11,*r10+                  ; Push return address onto the stack
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set the two MSbits to 01 for write
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdpwd
vdpcp0:
       mov  r2,r3
       srl  r3,3                       ; Number of groups of 8
       jeq  vdpcp2
vdpcp1:
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       movb *r1+,*r0
       dec  r3
       jne  vdpcp1
       andi r2,>0007                   ; Isolate number of remaining bytes
       jeq  vdpcp3
vdpcp2:
       movb *r1+,*r0
       dec  r2
       jne  vdpcp2
vdpcp3:
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// vdpcp

*********************************************************************
*
* Fast CPU to VDP write, replaces VSMW
*
* R0: Destination address
* R1: Byte to write in MSB
* R2: Number of bytes to copy
*
* Modifies r0-r3
*
vdpwr:
       swpb r0
       movb r0,@vdpwa                  ; Send low byte of VDP RAM write address
       swpb r0
       ori  r0,>4000                   ; Set the two MSbits to 01 for write
       movb r0,@vdpwa                  ; Send high byte of VDP RAM write address
       li   r0,vdpwd
       mov  r2,r3
       srl  r3,3                       ; Number of groups of 8
       jeq  vdpwr2
vdpwr1:
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       movb r1,*r0
       dec  r3
       jne  vdpwr1
       andi r2,>0007                   ; Isolate number of remaining bytes
       jeq  vdpwr3
vdpwr2:
       movb r1, *r0
       dec  r2
       jne  vdpwr2
vdpwr3:
       b    *r11
*// vdpwr

*********************************************************************
*
* Random number generator
*
rand:
       li   r0,28643                   ; A prime number to multiply by
       mpy  @rand_no,r0
       ai   r0,31873                   ; Add a prime number
       src  r0,7                       ; Shift to break odd/even pattern
       mov  r0,@rand_no
       b    *r11
*// rand

*********************************************************************************
*
* Play sound if interrupt has occurred
*
* Modifies r0-r1
*
play_sound_check:
       mov  r11,*r10+                  ; Push return address onto the stack
       clr  r12
       tb   2
       jeq  play_sound_check_1
       movb @vdpsta,@vdp_status
       mov  r0,*r10+
       mov  r1,*r10+
       bl   @play_sound
       dect r10
       mov  *r10,r1
       dect r10
       mov  *r10,r0
*      Return
play_sound_check_1:
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// play_sound_check

*********************************************************************
*
* Play music and sound
*
* Modifies r0-r1
*
play_sound:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  @music,r0
       jeq  play_sound_2
       stwp r0
       mov  r0,@play_sound_1+2
       mov  @cart_music_bank,r0
       seto *r0
       bl   @stplaysfx
play_sound_1:
       lwpi 0
       mov  @sndws+14,r0               ; Check if music is done
       jne  play_sound_2
       mov  @loop_music,r0
       jeq  play_sound_2
*      Restart music
       mov  @music,r1
       bl   @init_music
*      Return
play_sound_2:
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// play_sound

*********************************************************************
*
* Initialize music
*
* r1: Pointer to music
*
init_music:
       mov  r11,*r10+                  ; Push return address onto the stack
       bl   @mute_sound
       mov  r1,@music
       stwp r0
       mov  r0,@init_music_1+2
       lwpi callwp
       mov  @cart_music_bank,r0
       seto *r0
       mov  @music,r1
       mov  @tune_no,r2
       bl   @stinitsfx
       seto @loop_music                ; Set music to loop
init_music_1:
       lwpi 0
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// init_music

*********************************************************************
*
* Initialize sound fx
*
* r1: Pointer to sound fx data
*
init_sfx:
       mov  r11,*r10+                  ; Push return address onto the stack
       mov  r2,*r10+
       mov  r3,*r10+
       stwp r0
       mov  r0,@init_sfx_1+2
       mov  r1,@callwp+2
       lwpi callwp
       clr  r2
       li   r3,1
       bl   @sfxinitsfx
init_sfx_1:
       lwpi 0
       dect r10
       mov  *r10,r3
       dect r10
       mov  *r10,r2
*      Return
       dect r10                        ; Pop return address off the stack
       mov  *r10,r11
       b    *r11
*// init_sfx

*********************************************************************
*
* Mute sound
*
mute_sound:
       li   r0,mute_table              ; Mute all
       li   r2,4
mute_sound_1:
       movb *r0+,@sound
       dec  r2
       jne  mute_sound_1
       clr  @music
       b    *r11
mute_table:
       byte >9f, >bf, >df, >ff
*// mute_sound

***************************************************************************
*
* Wait for n frames
*
* r2: Number of frames to wait
*
wait:
       mov  r11,*r10+
wait_1:
       bl   @vsync
       bl   @play_sound
       dec  r2
       jgt  wait_1
*      Return
       dect r10
       mov  *r10,r11
       b    *r11
*// wait

***************************************************************************
*
* Wait for key press with timeout and callback
*
* r3: Number of frames to wait
* r4: Address of routine to call each frame
*
wait_key_timeout:
       mov  r11,*r10+
       clr  @frame_count
wait_key_timeout_1:
       bl   @check_quit
       bl   @any_key
       jne  wait_key_timeout_3
       bl   @vsync
       bl   @play_sound
       mov  r4,r4
       jeq  wait_key_timeout_2
       bl   *r4
wait_key_timeout_2:
       inc  @frame_count
       dec  r3
       jne  wait_key_timeout_1
*      Return
wait_key_timeout_3:
       dect r10
       mov  *r10,r11
       b    *r11
*// wait_key_timeout

***************************************************************************
*
* Wait for key press
*
wait_key:
       mov  r11,*r10+
wait_key_1:
       bl   @check_quit
       bl   @any_key
       jne  wait_key_2
       bl   @vsync
       bl   @play_sound
       jmp  wait_key_1
*      Return
wait_key_2:
       dect r10
       mov  *r10,r11
       b    *r11
*// wait_key

***************************************************************************
*
* Check quit
*
check_quit:
       clr  r1                         ; Test column 0
       li   r12,>0024                  ; Address for column selection
       ldcr r1,3                       ; Select column
       li   r12,>0006                  ; Address to read rows
       stcr r1,8
       andi r1,>1100
       jeq  quit
*      Return
       b    *r11
*      Quit
quit   clr  @>83c4                     ; Reset user ISR address
       blwp @>0000
*// check_quit

***************************************************************************
*
* Check key
*
* tmp0: Column in MSB: >0000 - >0700, Row in LSB: >0006 - >0014
*
*       Column   0      1    2    3    4    5     6       7
*     Row
*     >0006      =      .    ,    M    N    /    Fire    Fire
*     >0008    Space    L    K    J    H    ;    Left    Left
*     >000A    Enter    O    I    U    Y    P    Right   Right
*     >000C             9    8    7    6    0    Down    Down
*     >000E    Fctn     2    3    4    5    1    Up      Up
*     >0010    Shift    S    D    F    G    A
*     >0012    Ctrl     W    E    R    T    Q
*     >0014             X    C    V    B    Z
*
* On return NEQ means that the key is pressed
*
KEY_FI EQU  >0606
KEY_LF EQU  >0608
KEY_RG EQU  >060A
KEY_DN EQU  >060C
KEY_UP EQU  >060E
KEY_CM EQU  >0206
KEY_FS EQU  >0106
KEY_0  EQU  >050C
KEY_1  EQU  >050E
KEY_2  EQU  >010E
KEY_3  EQU  >020E
KEY_4  EQU  >030E
KEY_5  EQU  >040E
KEY_6  EQU  >040C
KEY_7  EQU  >030C
KEY_8  EQU  >020C
KEY_9  EQU  >010C
KEY_A  EQU  >0510
KEY_B  EQU  >0414
KEY_C  EQU  >0214
KEY_D  EQU  >0210
KEY_E  EQU  >0212
KEY_F  EQU  >0310
KEY_G  EQU  >0410
KEY_H  EQU  >0408
KEY_I  EQU  >020A
KEY_J  EQU  >0308
KEY_K  EQU  >0208
KEY_L  EQU  >0108
KEY_M  EQU  >0306
KEY_N  EQU  >0406
KEY_O  EQU  >010A
KEY_P  EQU  >050A
KEY_Q  EQU  >0512
KEY_R  EQU  >0312
KEY_S  EQU  >0110
KEY_T  EQU  >0412
KEY_U  EQU  >030A
KEY_V  EQU  >0314
KEY_W  EQU  >0112
KEY_X  EQU  >0114
KEY_Y  EQU  >040A
KEY_Z  EQU  >0514
KEY_SP EQU  >0008
KEY_EN EQU  >000A
KEY_FN EQU  >000E
KEY_SH EQU  >0010
KEY_CT EQU  >0012
*
check_key:
       li   r12,>0024                  ; CRU address of the column decoder
       ldcr r0,3                       ; Select column
       andi r0,>00ff
       mov  r0,r12                     ; Select row
       tb   0                          ; Test key, EQ if not pressed
       b    *r11
*// check_key

*********************************************************************
*
* Resets EQ (neq) if any key is pressed
*
any_key:
       clr  @user_input_device
       li   r1,>0000                   ; Column
any_key_1:
       li   r12,>0024                  ; CRU address of the column decoder
       mov  r1,r0
       swpb r0
       ldcr r0,3                       ; Select column
       li   r12,0006                   ; Select row
       stcr r0,8
       seto r2
       cb   r0,r2                      ; If any bit is reset a key is pressed
       jne  any_key_2
       inc  r1
       ci   r1,8
       jne  any_key_1
       jmp  any_key_3                   ; eq ok
any_key_2:
       ci   r1,6
       jne  any_key_3                   ; neq ok
       inc  @user_input_device         ; Still neq
any_key_3:
       b    *r11
*// any_key

*********************************************************************
*
* Include sprite handling routines
*
       copy "sprite-handling.a99"

*********************************************************************
*
* Data
*
boat_patterns_uploaded:                ; Is boat pattens uploaded to VDP?
       data 0
big_plane_patterns_uploaded:           ; Is big plane patterns uploaded to VDP?
       data 0
alloc_sprite_cnt:                      ; Used by alloc_sprite
       data 0
direction:                             ; Scroll direction. Used by update_characters
       data -1
loop_music:                            ; Is music looping?
       data 0
tune_no:                               ; Tune number
       data 0
**
* High scores
*
high_scores:
       bss  n_high_scores*4             ; High score table. 10 x 32 bit.
**
*
char_list:                             ; Pointers to pattern/color addresses for current character set
       bss  128*2                      ; Or -1 if the character is not currently used
map_heights:
       data 382, 450, 340, 364
**
* Text
*
txt_get_ready:
       byte >F0,>F3,>F7,>FF,>F6,>F3,>F1,>F8,>F9
txt_game_over:
       byte >F0,>F1,>F2,>F3,>FF,>F4,>F5,>F3,>F6
       even
**
* Music and sound fx
*
       copy "tiplayersfx.a99"
shot_1:
       bcopy "..\sound\shot2.vgm.spf"
expl_1:
       bcopy "..\sound\expl1.vgm.spf"
**
* Geometry lookup tables
*
       copy "geometry.a99"
**
* Sprite and panel graphics
*
       copy "sprite-patterns.a99"
       copy "panel.a99"
**
* Sprite definitions
*
sprite_defs:
       copy "sprite-defs.a99"
**
* Sprites
*
sprites:
       bss n_sprites*sprite_struct_size
sprite_player:
       equ  sprites
**
* Hardware sprites
*
hw_sprites:
       bss  n_hw_sprites*hw_sprite_struct_size

       aorg >2000
**
* Sprite positions and paths
*
       copy "sprite-pos-lists.a99"
       copy "waves.a99"
       copy "paths.a99"
**
*      End
*
       end  main
